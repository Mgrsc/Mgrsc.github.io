<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构(2)线性结构</title>
      <link href="/undefinedshuju2/"/>
      <url>/undefinedshuju2/</url>
      
        <content type="html"><![CDATA[<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性数据结构是一种数据组织方式，其元素在一条线上依次排列。这些数据结构的特点是元素之间存在前后关系，每个元素都最多只有一个前驱和一个后继。在实际应用中，线性数据结构被广泛使用，如链表、栈和队列等。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>栈</strong> 有时也被称作“下推栈”。它是有序集合，添加操作和移除操作总发生在同一端，即“顶端”，另一端则被称为“底端”。</p><p>栈中的元素离底端越近，代表其在栈中的时间越长，因此栈的底端具有非常重要的意义。最新添加的元素将被最先移除。这种排序原则被称作<strong>LIFO</strong> （last-in first-out），即后进先出。它提供了一种基于在集合中的时间来排序的方式。最近添加的元素靠近顶端，旧元素则靠近底端。</p><p>栈通常用于程序中需要“临时”保存数据的操作，特别适用于递归算法的实现、表达式求值、程序调用信息（包括递归函数和中断处理）、内存分配、缓冲区管理和追溯操作等方面的应用。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413105726209.png" alt="image-20230413105726209"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413110918618.png" alt="image-20230413110918618"></p><h5 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h5><ul><li><code>Stack()</code> 创建一个空栈。它不需要参数，且会返回一个空栈。</li><li><code>push(item)</code> 将一个元素添加到栈的顶端。它需要一个参数<code>item</code> ，且无返回值。</li><li><code>pop()</code> 将栈顶端的元素移除。它不需要参数，但会返回顶端的元素，并且修改栈的内容。</li><li><code>peek()</code> 返回栈顶端的元素，但是并不移除该元素。它不需要参数，也不会修改栈的内容。</li><li><code>isEmpty()</code> 检查栈是否为空。它不需要参数，且会返回一个布尔值。</li><li><code>size()</code> 返回栈中元素的数目。它不需要参数，且会返回一个整数。</li></ul><p>用python实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">      def __init__(self):</span><br><span class="line">           self.items = []</span><br><span class="line"></span><br><span class="line">      def isEmpty(self):</span><br><span class="line">           return self.items == []</span><br><span class="line">    </span><br><span class="line">      def push(self, item):</span><br><span class="line">           self.items.append(item)</span><br><span class="line">    </span><br><span class="line">      def pop(self):</span><br><span class="line">          return self.items.pop()</span><br><span class="line">    </span><br><span class="line">      def peek(self):</span><br><span class="line">          return self.items[len(self.items)-1]</span><br><span class="line">    </span><br><span class="line">      def size(self):</span><br><span class="line">          return len(self.items)</span><br></pre></td></tr></table></figure><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>匹配括号</p><p>由一个空栈开始，从左往右依次处理括号。如果遇到左括号，便通过<code>push</code> 操作将其加入栈中，以此表示稍后需要有一个与之匹配的右括号。反之，如果遇到右括号，就调用<code>pop</code> 操作。只要栈中的所有左括号都能遇到与之匹配的右括号，那么整个括号串就是匹配的；如果栈中有任何一个左括号找不到与之匹配的右括号，则括号串就是不匹配的。在处理完匹配的括号串之后，栈应该是空的。代码清单3-3展示了实现这一算法的Python代码。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413112321938.png" alt="image-20230413112321938"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pythonds.basic import Stack</span><br><span class="line"></span><br><span class="line">   def parChecker(symbolString):</span><br><span class="line">       s = Stack()</span><br><span class="line">       balanced = True</span><br><span class="line">       index = 0</span><br><span class="line">       while index &lt; len(symbolString) and balanced:</span><br><span class="line">           symbol = symbolString[index]</span><br><span class="line">           if symbol == &quot;(&quot;:</span><br><span class="line">              s.push(symbol)</span><br><span class="line">          else:</span><br><span class="line">              if s.isEmpty():</span><br><span class="line">                  balanced = False</span><br><span class="line">              else:</span><br><span class="line">                  s.pop()</span><br><span class="line"></span><br><span class="line">          index = index + 1</span><br><span class="line"></span><br><span class="line">      if balanced and s.isEmpty():</span><br><span class="line">          return True</span><br><span class="line">      else:</span><br><span class="line">          return False</span><br></pre></td></tr></table></figure><p>将十进制转为二进制</p><p><code>divideBy2</code> 函数接受一个十进制数作为参数，然后不停地将其除以2。第6行使用了内建的取余运算符<code>%</code> ，第7行将求得的余数压入栈中。当除法过程遇到0之后，第10~12行就会构建一个二进制数字串。第10行创建一个空串。随后，二进制数字从栈中被逐个取出，并添加到数字串的最右边。最后，函数返回该二进制数字串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pythonds.basic import Stack</span><br><span class="line">   def divideBy2(decNumber):</span><br><span class="line">       remstack = Stack()</span><br><span class="line"></span><br><span class="line">       while decNumber &gt; 0:</span><br><span class="line">           rem = decNumber % 2</span><br><span class="line">           remstack.push(rem)</span><br><span class="line">           decNumber = decNumber // 2</span><br><span class="line"></span><br><span class="line">      binString = &quot;&quot;</span><br><span class="line">      while not remstack.isEmpty():</span><br><span class="line">          binString = binString + str(remstack.pop())</span><br><span class="line"></span><br><span class="line">      return binString</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列</strong> 是有序集合，添加操作发生在“尾部”，移除操作则发生在“头部”。新元素从尾部进入队列，然后一直向前移动到头部，直到成为下一个被移除的元素。</p><p>最新添加的元素必须在队列的尾部等待，在队列中时间最长的元素则排在最前面。这种排序原则被称作<strong>FIFO</strong>（first-in first-out），即先进先出，也称先到先得。</p><p>在日常生活中，我们经常排队，这便是最简单的队列例子。进电影院要排队，在超市结账要排队，买咖啡也要排队（等着从盘子栈中取盘子）。好的队列只允许一头进，另一头出，不可能发生插队或者中途离开的情况。图3-12展示了一个由Python数据对象组成的简单队列。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413113253807.png" alt="image-20230413113253807"></p><h5 id="队列的ADT"><a href="#队列的ADT" class="headerlink" title="队列的ADT"></a>队列的ADT</h5><ul><li><code>Queue()</code> 创建一个空队列。它不需要参数，且会返回一个空队列。</li><li><code>enqueue(item)</code> 在队列的尾部添加一个元素。它需要一个元素作为参数，不返回任何值。</li><li><code>dequeue()</code> 从队列的头部移除一个元素。它不需要参数，且会返回一个元素，并修改队列的内容。</li><li><code>isEmpty()</code> 检查队列是否为空。它不需要参数，且会返回一个布尔值。</li><li><code>size()</code> 返回队列中元素的数目。它不需要参数，且会返回一个整数。</li></ul><p>python实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Queue:</span><br><span class="line">       def __init__(self):</span><br><span class="line">           self.items = []</span><br><span class="line"></span><br><span class="line">       def isEmpty(self):</span><br><span class="line">           return self.items == []</span><br><span class="line"></span><br><span class="line">       def enqueue(self, item):</span><br><span class="line">           self.items.insert(0, item)</span><br><span class="line"></span><br><span class="line">      def dequeue(self):</span><br><span class="line">          return self.items.pop()</span><br><span class="line"></span><br><span class="line">      def size(self):</span><br><span class="line">          return len(self.items)</span><br></pre></td></tr></table></figure><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p><strong>双端队列</strong> 是与队列类似的有序集合。它有一前、一后两端，元素在其中保持自己的位置。与队列不同的是，双端队列对在哪一端添加和移除元素没有任何限制。新元素既可以被添加到前端，也可以被添加到后端。同理，已有的元素也能从任意一端移除。某种意义上，双端队列是栈和队列的结合。图3-16展示了由Python数据对象组成的双端队列。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413113858577.png" alt="image-20230413113858577"></p><p>尽管双端队列有栈和队列的很多特性，但是它并不要求按照这两种数据结构分别规定的LIFO原则和FIFO原则操作元素。具体的排序原则取决于其使用者。</p><h5 id="双端队列的ADT"><a href="#双端队列的ADT" class="headerlink" title="双端队列的ADT"></a>双端队列的ADT</h5><ul><li><code>Deque()</code> 创建一个空的双端队列。它不需要参数，且会返回一个空的双端队列。</li><li><code>addFront(item)</code> 将一个元素添加到双端队列的前端。它接受一个元素作为参数，没有返回值。</li><li><code>addRear(item)</code> 将一个元素添加到双端队列的后端。它接受一个元素作为参数，没有返回值。</li><li><code>removeFront()</code> 从双端队列的前端移除一个元素。它不需要参数，且会返回一个元素，并修改双端队列的内容。</li><li><code>removeRear()</code> 从双端队列的后端移除一个元素。它不需要参数，且会返回一个元素，并修改双端队列的内容。</li><li><code>isEmpty()</code> 检查双端队列是否为空。它不需要参数，且会返回一个布尔值。</li><li><code>size()</code> 返回双端队列中元素的数目。它不需要参数，且会返回一个整数。</li></ul><p>python实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Deque:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def addFront(self, item):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">   def addRear(self, item):</span><br><span class="line">       self.items.insert(0, item)</span><br><span class="line"></span><br><span class="line">   def removeFront(self):</span><br><span class="line">       return self.items.pop()</span><br><span class="line"></span><br><span class="line">   def removeRear(self):</span><br><span class="line">       return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">   def size(self):</span><br><span class="line">       return len(self.items)</span><br></pre></td></tr></table></figure><h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>回文检测</p><p>使用一个双端队列来存储字符串中的字符。按从左往右的顺序将字符串中的字符添加到双端队列的后端。此时，该双端队列类似于一个普通的队列。然而，可以利用双端队列的双重性，其前端是字符串的第一个字符，后端是字符串的最后一个字符，由于可以从前后两端移除元素，因此我们能够比较两个元素，并且只有在二者相等时才继续。如果一直匹配第一个和最后一个元素，最终会处理完所有的字符（如果字符数是偶数），或者剩下只有一个元素的双端队列（如果字符数是奇数）。任意一种结果都表明输入字符串是回文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pythonds.basic import Deque</span><br><span class="line">def palchecker(aString):</span><br><span class="line">    chardeque = Deque()</span><br><span class="line"></span><br><span class="line">    for ch in aString:</span><br><span class="line">        chardeque.addRear(ch)</span><br><span class="line"></span><br><span class="line">    stillEqual = True</span><br><span class="line"></span><br><span class="line">   while chardeque.size() &gt; 1 and stillEqual:</span><br><span class="line">       first = chardeque.removeFront()</span><br><span class="line">       last = chardeque.removeRear()</span><br><span class="line">       if first != last:</span><br><span class="line">           stillEqual = False</span><br><span class="line"></span><br><span class="line">   return stillEqual</span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413114152748.png" alt="image-20230413114152748"></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>并非所有编程语言都有列表。对于不提供列表的编程语言，程序员必须自己动手实现。</p><p><strong>列表</strong> 是元素的集合，其中每一个元素都有一个相对于其他元素的位置。更具体地说，这种列表称为无序列表。可以认为列表有第一个元素、第二个元素、第三个元素，等等；也可以称第一个元素为列表的起点，称最后一个元素为列表的终点。为简单起见，我们假设列表中没有重复元素。</p><p>假设54, 26, 93, 17, 77, 31是考试分数的无序列表。注意，列表通常使用逗号作为分隔符。这个列表在Python中显示为<code>[54, 26, 93, 17, 77, 31]</code> 。</p><h5 id="无序列表的ADT"><a href="#无序列表的ADT" class="headerlink" title="无序列表的ADT"></a>无序列表的ADT</h5><ul><li><code>List()</code> 创建一个空列表。它不需要参数，且会返回一个空列表。</li><li><code>add(item)</code> 假设元素<code>item</code> 之前不在列表中，并向其中添加<code>item</code> 。它接受一个元素作为参数，无返回值。</li><li><code>remove(item)</code> 假设元素<code>item</code> 已经在列表中，并从其中移除<code>item</code> 。它接受一个元素作为参数，并且修改列表。</li><li><code>search(item)</code> 在列表中搜索元素<code>item</code> 。它接受一个元素作为参数，并且返回布尔值。</li><li><code>isEmpty()</code> 检查列表是否为空。它不需要参数，并且返回布尔值。</li><li><code>length()</code> 返回列表中元素的个数。它不需要参数，并且返回一个整数。</li><li><code>append(item)</code> 假设元素<code>item</code> 之前不在列表中，并在列表的最后位置添加<code>item</code> 。它接受一个元素作为参数，无返回值。</li><li><code>index(item)</code> 假设元素<code>item</code> 已经在列表中，并返回该元素在列表中的位置。它接受一个元素作为参数，并且返回该元素的下标。</li><li><code>insert(pos, item)</code> 假设元素<code>item</code> 之前不在列表中，同时假设<code>pos</code> 是合理的值，并在位置<code>pos</code> 处添加元素<code>item</code> 。它接受两个参数，无返回值。</li><li><code>pop()</code> 假设列表不为空，并移除列表中的最后一个元素。它不需要参数，且会返回一个元素。</li><li><code>pop(pos)</code> 假设在指定位置<code>pos</code> 存在元素，并移除该位置上的元素。它接受位置参数，且会返回一个元素。</li></ul><p>python实现无序列表</p><p>构建<strong>链表</strong> 。无序列表需要维持元素之间的相对位置，但是并不需要在连续的内存空间中维护这些位置信息。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413115051171.png" alt="image-20230413115051171"></p><p>必须指明列表中第一个元素的位置。一旦知道第一个元素的位置，就能根据其中的链接信息访问第二个元素，接着访问第三个元素，依此类推。指向链表第一个元素的引用被称作<strong>头</strong> 。最后一个元素需要知道自己没有下一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建node类，node是链表的基本数据结构，每一个node对象有两份信息：1.列表元素（节点的数据变量）2.节点必须保存指向下一个节点的引用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initdata</span>):</span><br><span class="line">        self.data = initdata</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment">#将节点接地</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetData</span>(<span class="params">self</span>):<span class="comment">#获取数据</span></span><br><span class="line">        <span class="keyword">return</span> self.data()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetNext</span>(<span class="params">self</span>):<span class="comment">#获取下一个节点数据</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self, newdata</span>)：</span><br><span class="line">        self.data = newdata</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setNext</span>(<span class="params">self, newnext</span>):</span><br><span class="line">        self.<span class="built_in">next</span> = newnext</span><br><span class="line">        </span><br><span class="line"><span class="comment">#UnordaeredList类无序列表基于节点构建，每一个node都显示的引用指向下一个节点，只要知道第一个节点位置，其后所有node都来可以通过下标应用找到，英雌UnordaereList类必须指向第一个节点的引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span> <span class="comment">#标名列表头部没有指向任何节点</span></span><br><span class="line"><span class="comment">#列表类本身不包含任何节点对象，而只有指向整个列表结构中第一个节点得引用，在Python中，None 可以和任何引用进行比较。如果两个引用都指向同一个对象，那么它们就是相等的。我们将在后面的方法中经常使用这一特性。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="literal">None</span></span><br><span class="line"><span class="comment">#实现add，因为是无序列表所以随便放，有于链表只提供一个入口（头部），因此其他所有节点只能通过第一个节点以及next连接来访问，那么添加最简便得位置就是头部，把已有的元素连接到该元素后面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        temp = Node(item) <span class="comment">#创建新节点</span></span><br><span class="line">        temp.setNext(self.head)<span class="comment"># #设置下一个节点</span></span><br><span class="line">        self.head = temp <span class="comment">#修改列表头节点</span></span><br><span class="line"><span class="comment">#如果先修改列表的头节点那么将导致已有节点丢失</span></span><br><span class="line"><span class="comment">#实现length方法需要遍历链表并且记录访问过多少个节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head<span class="comment">#下一个引用</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">            count = count + <span class="number">1</span></span><br><span class="line">            current = current.getNext()</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"><span class="comment">#在无序列表中搜索一个值也需要遍历，每访问一个节点就要检查该节点得元素是否于搜索的元素相同</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line"><span class="comment">#当current不等于none即还有下一个节点和found为假时继续即还没找到</span></span><br><span class="line">            <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.getNext()</span><br><span class="line">         <span class="keyword">return</span> found</span><br><span class="line"><span class="comment">#remove方法需要两部1.遍历列表并查找要移除得元素2.使用两个外部引用，current和之前一样，previous指向current上一次访问得节点。当current指向需要被移除得节点时previous刚好指向真正需要修改得节点。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> found:<span class="comment">#found不为真</span></span><br><span class="line">            <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">                found = <span class="literal">True</span><span class="comment">#判断是否为要移除得，是则设found为true</span></span><br><span class="line">            <span class="keyword">else</span>:   <span class="comment">#不是就将previous和current向前移动依次</span></span><br><span class="line">                previous = current</span><br><span class="line">                <span class="comment">#先把previous移动到current位置</span></span><br><span class="line">                current = current.getNext()</span><br><span class="line">                <span class="comment">#再移动current，这一过程常称为蠕动</span></span><br><span class="line">        <span class="keyword">if</span> previous == <span class="literal">None</span>:</span><br><span class="line">            self.head = current.getNext()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            previous.setNext(current.getNext())</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414145135186.png" alt="image-20230414145135186"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414150058739.png" alt="image-20230414150058739"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414151144900.png" alt="image-20230414151144900"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414151905120.png" alt="image-20230414151905120"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414152313044.png" alt="image-20230414152313044"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414153116801.png" alt="image-20230414153116801"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414153238448.png" alt="image-20230414153238448"></p><h5 id="有序列表的ADT"><a href="#有序列表的ADT" class="headerlink" title="有序列表的ADT"></a>有序列表的ADT</h5><ul><li><code>OrderedList()</code> 创建一个空有序列表。它不需要参数，且会返回一个空列表。</li><li><code>add(item)</code> 假设<code>item</code> 之前不在列表中，并向其中添加<code>item</code> ，同时保持整个列表的顺序。它接受一个元素作为参数，无返回值。</li><li><code>remove(item)</code> 假设<code>item</code> 已经在列表中，并从其中移除<code>item</code> 。它接受一个元素作为参数，并且修改列表。</li><li><code>search(item)</code> 在列表中搜索<code>item</code> 。它接受一个元素作为参数，并且返回布尔值。</li><li><code>isEmpty()</code> 检查列表是否为空。它不需要参数，并且返回布尔值。</li><li><code>length()</code> 返回列表中元素的个数。它不需要参数，并且返回一个整数。</li><li><code>index(item)</code> 假设<code>item</code> 已经在列表中，并返回该元素在列表中的位置。它接受一个元素作为参数，并且返回该元素的下标。</li><li><code>pop()</code> 假设列表不为空，并移除列表中的最后一个元素。它不需要参数，且会返回一个元素。</li><li><code>pop(pos)</code> 假设在指定位置<code>pos</code> 存在元素，并移除该位置上的元素。它接受位置参数，且会返回一个元素。</li></ul><p>python实现有序列表</p><p>其中每个元素都有一个明确的位置。它们通常用于存储和访问<strong>按特定顺序排序的数据</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"><span class="comment">#isempty和length仅于列表中得节点数目有关和实际的元素值无关所以和无序列表类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在有序列表中搜索一旦节点中得值比正在查找得值更大，搜索立即结束并返回false</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">search, item</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">            <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">                    stop = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current = current.current.getNext()</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"><span class="comment">#在有序列表中添加元素需要找到合适的位置插入，当访问完所有节点或者当前值大于要添加元素时就找到了要插入的位置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">            <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                previous = current</span><br><span class="line">                current = current.getNext()</span><br><span class="line">        temp = Node(item)</span><br><span class="line">        <span class="keyword">if</span> previous == <span class="literal">None</span>:</span><br><span class="line">            temp.setNext(self.head)</span><br><span class="line">            self.head = temp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp.setNext(current)</span><br><span class="line">            previous.setNext(temp)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414154826796.png" alt="image-20230414154826796"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230414155112549.png" alt="image-20230414155112549"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（1）基础知识</title>
      <link href="/undefinedshuju/"/>
      <url>/undefinedshuju/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数据结构</span><br><span class="line">├─ 线性结构</span><br><span class="line">│  ├─ 数组</span><br><span class="line">│  ├─ 链表</span><br><span class="line">│  ├─ 栈</span><br><span class="line">│  └─ 队列</span><br><span class="line">├─ 树形结构</span><br><span class="line">│  ├─ 二叉树</span><br><span class="line">│  ├─ AVL树</span><br><span class="line">│  ├─ B树</span><br><span class="line">│  └─ ...</span><br><span class="line">├─ 图形结构</span><br><span class="line">│  ├─ 有向图</span><br><span class="line">│  └─ 无向图</span><br><span class="line">├─ 散列表结构</span><br><span class="line">│  └─ 哈希表</span><br><span class="line">└─ 其他特殊结构</span><br><span class="line">   ├─ 堆</span><br><span class="line">   ├─ 并查集</span><br><span class="line">   └─ 线段树</span><br></pre></td></tr></table></figure><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据结构是为了方便对数据进行操作而设计的一种组织形式。它可以用来表示不同的数据类型，并提供各种操作方法，例如插入、删除、搜索、排序等。在计算机程序中，数据结构扮演着非常重要的角色，因为程序需要处理大量的数据并对其进行高效的操作。</p><p>数据结构是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据</p><p>数据结构描述数据元素的组织方式和对其进行操作的方式，而ADT定义一组操作及其规范性行为，从程序设计者的角度来看待数据类型。</p><p>常见的数据结构有数组、链表、栈、队列、树、图等，它们具有不同的特点和应用场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在计算机中，不同的数据类型（如整型、浮点型、字符型等）将数据表示为特定的比特组合方式，从而赋予其特定的实际意义和用途。例如，在32位整型中，采用二进制补码表示负数，而对于单精度浮点型，使用指数表达科学计数法。</span><br><span class="line"></span><br><span class="line">随着数据类型的确定，数据需要以一定的方式组织和管理，这就需要使用适当的数据结构。例如，在程序中需要使用栈(Stack)来生成函数调用堆栈、使用链表(Linked List)来实现哈希表、使用树(Tree)来表示文件系统等。数据结构的使用是为了更好地存储数据，方便进行相应的操作。</span><br><span class="line"></span><br><span class="line">最后，通过ADT的规范，程序开发者可以声明一组操作，从而规范程序使用这些数据的方法。ADT的定义使得程序开发者不必关心许多数据细节而能专注于算法和程序的设计和实现。例如，由于Python中列表(list)实现了队列(Queue)的ADT，所以程序开发者可以使用相应的队列操作来管理列表，而不必关心列表的具体实现。这种分离抽象的设计思想，有助于程序的设计和实现。</span><br></pre></td></tr></table></figure><p>学习数据结构可以帮助你更好地理解和设计计算机程序，<strong>提高程序效率和可维护性</strong>。</p><p>计算机中的所有数据实例均由二进制字符串来表达。为了赋予这些数据实际的意义，必须要有数据类型。数据类型能够帮助我们解读二进制数据的含义，从而使我们能从待解决问题的角度来看待数据。这些<strong>内建的底层数据类型</strong>（又称<strong>原生数据类型</strong>，比如python的int()）提供了算法开发的基本单元。</p><p>ADT（抽象数据类型）定义了一组操作，这些操作可以在不考虑实现细节的情况下执行。换句话说，ADT只关注数据类型的行为和语义，而不关心它的内部实现。因此，ADT提供了一个高层次的视角来描述数据类型，使得程序员不必了解其底层实现即可使用它们。例如，队列、堆栈、集合等都是ADT。</p><p>为了控制问题及其求解过程的复杂度，使用过程抽象的将细节隐藏起来（python的input()函数），数据抽象的基本思想与此类似，<strong>抽象数据类型（ADT）</strong>从逻辑上描述了如何看待数据以及其对应运算而无需考虑实现。</p><p>该抽象对数据进行<strong>封装</strong>提供了接口，这称为信息隐藏</p><p>而抽象数据类型的实现称为<strong>数据结构</strong></p><p>eg.实现stack的ADT</p><p>在ADT的描述中，栈(Stack)是一种后进先出（Last-In-First-Out，LIFO）的抽象数据类型，只允许在一端进行插入和删除元素的操作，该端称为栈顶(top)。栈可以用顺序存储结构（即数组）或链式存储结构来实现，它的主要操作如下：</p><ul><li>push(item)：将元素item压入栈顶</li><li>pop()：删除并返回栈顶元素</li><li>top()：返回栈顶元素</li><li>is_empty()：判断栈是否为空</li></ul><p>下面是用Python列表来实现栈的ADT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return len(self.items) == 0</span><br><span class="line"></span><br><span class="line">    def push(self, item):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def top(self):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return None</span><br><span class="line">        return self.items[-1]</span><br></pre></td></tr></table></figure><p>在这个Stack类中，我们使用Python列表来存储栈的元素，此处的列表可以看作是数组，用列表的append和pop方法来进行元素插入和删除操作，用len方法来判断栈是否为空，用最后一个元素的索引来查看栈顶元素。通过这些方法，我们实现了栈的ADT。用户只需要调用栈的方法就可以对栈进行操作，而不需要关心具体的实现细节。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412103141581.png" alt="image-20230412103141581"></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ol><li>数据元素：指一个数据结构中的<strong>基本单位</strong>，也可以称为节点、元素、项等。每个数据元素包含若干个数据项（属性），用来描述某个实体或对象。</li><li>数据结构：指不同类型<strong>数据元素之间的关系</strong>，以及对这些元素进行操作的方法集合。常见的数据结构包括数组、链表、栈、队列、树、图等。</li><li>线性结构：指数据元素之间存在线性关系（即一对一的关系），例如数组、链表、栈和队列等。</li><li>非线性结构：指数据元素之间不存在简单的线性关系，例如树、图等。非线性结构通常具有层次性或者网状性。</li><li>子结构：指一个数据结构中的某个部分，可以看做是一种相对独立的小型数据结构，例如树的子树、链表的子链等。</li><li>抽象数据类型（ADT）：指数据类型的抽象表示，它定义了数据元素的集合、数据元素之间的逻辑关系以及对数据元素的基本操作。ADT与具体实现没有关系，只关注数据类型本身的特征和操作。</li><li>栈：指一种先进后出（LIFO）的数据结构，只允许在栈顶进行插入和删除操作。</li><li>队列：指一种先进先出（FIFO）的数据结构，只允许在队尾进行插入操作，在队头进行删除操作。</li><li>树：指一种层次结构的数据结构，由若干个节点和边组成。其中，根节点没有父节点，其他节点都有唯一的父节点，可以有零个或多个子节点。</li><li>图：指由若干个节点和边组成的数据结构，其中每个节点表示一个数据元素，每条边表示节点之间的关系。</li></ol><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><p>python支持面向对象编程，类都是对数据的构成（状态）以及数据能做什么（行为）的描述。</p><p>类与抽象数据类型相似，在面向对象编程范式中，数据项被称为对象，一个对象就是一个实例。</p><h3 id="内建原子数据类型"><a href="#内建原子数据类型" class="headerlink" title="内建原子数据类型"></a><strong>内建原子数据类型</strong></h3><p>python提供了两大内建数据类实现了int类型和float类型可以进行标准的数学运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2+3*4</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; (2+3)*4</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; 2**10</span><br><span class="line">1024</span><br><span class="line">&gt;&gt;&gt; 6/3</span><br><span class="line">2.0</span><br><span class="line">&gt;&gt;&gt; 7/3</span><br><span class="line">2.3333333333333335</span><br><span class="line">&gt;&gt;&gt; 7//3</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 7%3</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 3/6</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 3//6</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 3%6</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 2**100</span><br><span class="line">1267650600228229401496703205376</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>python通过bool类实现布尔数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; False or True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; not (False or True)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; True and True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 5 == 10</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 10 &gt; 5</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412103653616.png" alt="image-20230412103653616"></p><p>标识符在编程语言中被用作名字。python中的标识符以字母或下划线开头区分大小写，任意长度。</p><p>当一个名字第一次出现在赋值语句左边，会创建对应的python变量。赋值语句将名字和值关联起来。</p><p>python先计算右侧的表达式，然后判断数据类型并赋值给变量，体现了python的动态特性</p><p>变量存储的时指向数据的应用，而不是数据本身，类似一个内存指针</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412103953092.png" alt="image-20230412103953092"></p><h3 id="内建集合数据类型"><a href="#内建集合数据类型" class="headerlink" title="内建集合数据类型"></a>内建集合数据类型</h3><p>列表、字符串以及元组时概念上非常相似的有序集合。集（set）和字典时无序集合。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是零个或多个指向Python数据对象的引用的有序集合，通过在方括号内以逗号分隔的一系列值来表达。空列表就是［］。</p><p>列表是异构的，一个列表中可以包含不同类型的元素，这些元素的数据类型可以不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [1,3,True,6.5]</span><br><span class="line">[1, 3, True, 6.5]</span><br><span class="line">&gt;&gt;&gt; myList = [1,3,True,6.5]</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1, 3, True, 6.5]</span><br></pre></td></tr></table></figure><p>由于列表是有序的，它支持一系列可应用与任意python序列的运算</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412104922744.png" alt="image-20230412104922744"></p><p>列表和序列的下表从0开始。mylist[1:3]会返回一个下标从1到2的元素列表并没有包含3，</p><p>需要快速初始化列表可以通过重复运算来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mylist=[0]*6</span><br><span class="line">print(mylist)</span><br><span class="line">[0, 0, 0, 0, 0,]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; myList = [1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; A = [myList]*3</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">[[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]</span><br><span class="line">&gt;&gt;&gt; myList[2] = 45</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">[[1, 2, 45, 4], [1, 2, 45, 4], [1, 2, 45, 4]]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412105532325.png" alt="image-20230412105532325"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412105542404.png" alt="image-20230412105542404"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 3, True, 6.5]</span><br><span class="line">&gt;&gt;&gt; myList.append(False)</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 3, True, 6.5, False]</span><br><span class="line">&gt;&gt;&gt; myList.insert(2,4.5)</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 3, 4.5, True, 6.5, False]</span><br><span class="line">&gt;&gt;&gt; myList.pop()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 3, 4.5, True, 6.5]</span><br><span class="line">&gt;&gt;&gt; myList.pop(1)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 4.5, True, 6.5]</span><br><span class="line">&gt;&gt;&gt; myList.pop(2)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 4.5, 6.5]</span><br><span class="line">&gt;&gt;&gt; myList.sort()</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[4.5, 6.5, 1024]</span><br><span class="line">&gt;&gt;&gt; myList.reverse()</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 6.5, 4.5]</span><br><span class="line">&gt;&gt;&gt; myList.count(6.5)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; myList.index(4.5)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; myList.remove(6.5)</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[1024, 4.5]</span><br><span class="line">&gt;&gt;&gt; del myList[0]</span><br><span class="line">&gt;&gt;&gt; myList</span><br><span class="line">[4.5]</span><br></pre></td></tr></table></figure><p>句点符号mylist.sort()用来调用某个对象的方法，请求mylist调用其sort方法并传入空的参数。</p><p>range()会生成一个代表值序列的范围对象。使用list函数，能够以列表形式看到范围对象的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(10)</span><br><span class="line">range(0, 10)</span><br><span class="line">&gt;&gt;&gt; list(range(10))</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; range(5,10)</span><br><span class="line">range(5, 10)</span><br><span class="line">&gt;&gt;&gt; list(range(5,10))</span><br><span class="line">[5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; list(range(5,10,2))  #2代表步长</span><br><span class="line">[5, 7, 9]</span><br><span class="line">&gt;&gt;&gt; list(range(10,1,-1))  </span><br><span class="line">[10, 9, 8, 7, 6, 5, 4, 3, 2]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>是零个或多个字母、数字和其他符号的有序集合。这些字母、数字和其他符号被称为字符。常量字符通过引号和标识符进行区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;David&quot;</span><br><span class="line">&#x27;David&#x27;</span><br><span class="line">&gt;&gt;&gt; myName = &quot;David&quot;</span><br><span class="line">&gt;&gt;&gt; myName[3]</span><br><span class="line">&#x27;i&#x27;</span><br><span class="line">&gt;&gt;&gt; myName*2</span><br><span class="line">&#x27;DavidDavid&#x27;</span><br></pre></td></tr></table></figure><p>python字符串的方法</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412110250549.png" alt="image-20230412110250549"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myName</span><br><span class="line">&#x27;David&#x27;</span><br><span class="line">&gt;&gt;&gt; myName.upper()</span><br><span class="line">&#x27;DAVID&#x27;</span><br><span class="line">&gt;&gt;&gt; myName.center(10)</span><br><span class="line">&#x27;  David   &#x27;</span><br><span class="line">&gt;&gt;&gt; myName.find(&#x27;v&#x27;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; myName.split(&#x27;v&#x27;)</span><br><span class="line">[&#x27;Da&#x27;, &#x27;id&#x27;]</span><br></pre></td></tr></table></figure><p>列表和字符串的主要区别在于，列表可以修改字符串不能。列表的这一特性叫<strong>可修改性</strong></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>由于都是异构数据序列，因此元组和列表非常相似</p><p>他们的区别在于，元组和字符串一样不可修改，元组通常写成由括号并且以逗号分隔的一系列值，与序列一样，元组允许和字符串一样的任何操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myTuple = (2,True,4.96)</span><br><span class="line">&gt;&gt;&gt; myTuple</span><br><span class="line">(2, True, 4.96)</span><br><span class="line">&gt;&gt;&gt; len(myTuple)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; myTuple[0]</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; myTuple * 3</span><br><span class="line">(2, True, 4.96, 2, True, 4.96, 2, True, 4.96)</span><br><span class="line">&gt;&gt;&gt; myTuple[0:2]</span><br><span class="line">(2, True)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>元组和字符串是两种不同的数据类型，它们有以下区别：</p><ol><li>可变性：字符串是不可变的，即它们的值在创建后无法修改。而元组是可变的，虽然元组中的元素本身不可变，但是我们可以修改元组中元素的值或者增删元素。</li><li>数据类型：字符串是由单个字符组成的序列，而元组是由多个任意类型的元素组成的序列。因此，元组可以包含任何数据类型的元素，包括数字、字符串、列表、字典等。</li><li>表示方式：字符串用单引号、双引号或三引号表示，而元组使用圆括号表示。</li><li>用途：字符串常用于表示文本信息，如文件内容、用户输入、输出信息等。元组则常用于存储和传递数据，如函数返回多个值时，可以用元组来打包这些值并返回。</li></ol><h4 id="集（set）"><a href="#集（set）" class="headerlink" title="集（set）"></a>集（set）</h4><p>由零个或多个不可修改的python数据对象组成的无序集合。集不允许重复元素，并且写成由花括号包含、以逗号分隔的一系列值。，空集set()，集也是异构的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;3, 6, &quot;cat&quot;, 4.5, False&#125;</span><br><span class="line">&#123;False, 4.5, 3, 6, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; mySet = &#123;3, 6, &quot;cat&quot;, 4.5, False&#125;</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;False, 4.5, 3, 6, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>set支持的运算</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412110903885.png" alt="image-20230412110903885"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;False, 4.5, 3, 6, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; len(mySet)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; False in mySet</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;dog&quot; in mySet</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>set提供的方法</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412110948812.png" alt="image-20230412110948812"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;False, 4.5, 3, 6, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; yourSet = &#123;99,3,100&#125;</span><br><span class="line">&gt;&gt;&gt; mySet.union(yourSet)</span><br><span class="line">&#123;False, 4.5, 3, 100, 6, &#x27;cat&#x27;, 99&#125;</span><br><span class="line">&gt;&gt;&gt; mySet | yourSet</span><br><span class="line">&#123;False, 4.5, 3, 100, 6, &#x27;cat&#x27;, 99&#125;</span><br><span class="line">&gt;&gt;&gt; mySet.intersection(yourSet)</span><br><span class="line">&#123;3&#125;</span><br><span class="line">&gt;&gt;&gt; mySet &amp; yourSet</span><br><span class="line">&#123;3&#125;</span><br><span class="line">&gt;&gt;&gt; mySet.difference(yourSet)</span><br><span class="line">&#123;False, 4.5, 6, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; mySet - yourSet</span><br><span class="line">&#123;False, 4.5, 6, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;3,100&#125;.issubset(yourSet)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#123;3,100&#125;&lt;=yourSet</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; mySet.add(&quot;house&quot;)</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;False, 4.5, 3, 6, &#x27;house&#x27;, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; mySet.remove(4.5)</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;False, 3, 6, &#x27;house&#x27;, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; mySet.pop()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;3, 6, &#x27;house&#x27;, &#x27;cat&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; mySet.clear()</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">set()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典是无序结构，由相关元素对构成，其中每对元素都由一个key和一个value组成，写成key:value</p><p>字典由花括号包含一些列以逗号分隔的键值对表达</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; capitals = &#123;&#x27;Iowa&#x27;:&#x27;DesMoines&#x27;,&#x27;Wisconsin&#x27;:&#x27;Madison&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; capitals</span><br><span class="line">&#123;&#x27;Wisconsin&#x27;:&#x27;Madison&#x27;, &#x27;Iowa&#x27;:&#x27;DesMoines&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问字典通过key来访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; capitals[&#x27;Iowa&#x27;]</span><br><span class="line">&#x27;DesMoines&#x27;</span><br><span class="line">&gt;&gt;&gt; capitals[&#x27;Utah&#x27;]=&#x27;SaltLakeCity&#x27;</span><br><span class="line">&gt;&gt;&gt; capitals</span><br><span class="line">&#123;&#x27;Utah&#x27;:&#x27;SaltLakeCity&#x27;, &#x27;Wisconsin&#x27;:&#x27;Madison&#x27;, &#x27;Iowa&#x27;:&#x27;DesMoines&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; capitals[&#x27;California&#x27;]=&#x27;Sacramento&#x27;</span><br><span class="line">&gt;&gt;&gt; capitals</span><br><span class="line">&#123;&#x27;Utah&#x27;:&#x27;SaltLakeCity&#x27;, &#x27;Wisconsin&#x27;:&#x27;Madison&#x27;, &#x27;Iowa&#x27;:&#x27;DesMoines&#x27;, &#x27;California&#x27;:&#x27;Sacramento&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; len(capitals)</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>字典不是根据key来进行有序维护的，key的位置是由散列来决定的</p><p>字典的运算</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412111638121.png" alt="image-20230412111638121"></p><p>字典的方法</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412111650136.png" alt="image-20230412111650136"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; phoneext=&#123;&#x27;david&#x27;:1410, &#x27;brad&#x27;:1137&#125;</span><br><span class="line">&gt;&gt;&gt; phoneext</span><br><span class="line">&#123;&#x27;brad&#x27;:1137, &#x27;david&#x27;:1410&#125;</span><br><span class="line">&gt;&gt;&gt; phoneext.keys()</span><br><span class="line">dict_keys([&#x27;brad&#x27;, &#x27;david&#x27;])</span><br><span class="line">&gt;&gt;&gt; list(phoneext.keys())</span><br><span class="line">[&#x27;brad&#x27;, &#x27;david&#x27;]</span><br><span class="line">&gt;&gt;&gt; phoneext.values()</span><br><span class="line">dict_values([1137, 1410])</span><br><span class="line">&gt;&gt;&gt; list(phoneext.values())</span><br><span class="line">[1137, 1410]</span><br><span class="line">&gt;&gt;&gt; phoneext.items()</span><br><span class="line">dict_items([(&#x27;brad&#x27;, 1137), (&#x27;david&#x27;, 1410)])</span><br><span class="line">&gt;&gt;&gt; list(phoneext.items())</span><br><span class="line">[(&#x27;brad&#x27;, 1137), (&#x27;david&#x27;, 1410)]</span><br><span class="line">&gt;&gt;&gt; phoneext.get(&quot;kent&quot;)</span><br><span class="line">&gt;&gt;&gt; phoneext.get(&quot;kent&quot;, &quot;NO ENTRY&quot;)</span><br><span class="line">&#x27;NO ENTRY&#x27;</span><br></pre></td></tr></table></figure><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><h4 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h4><p>input()函数接受一个字符串作为参数。由于该字符串包含有用的文本来提示用户输入，因此它经常被称为提示字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aName = input(&#x27;Please enter your name: &#x27;)</span><br></pre></td></tr></table></figure><p><code>input</code> 函数返回的值是一个字符串，它包含用户在提示字符串后面输入的所有字符。如果需要将这个字符串转换成其他类型，必须明确地提供类型转换。在下面的语句中，用户输入的字符串被转换成了浮点数，以便于后续的算术处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sradius = input(&quot;Please enter the radius of the circle &quot;)</span><br><span class="line">radius = float(sradius)</span><br><span class="line">diameter = 2 * radius</span><br></pre></td></tr></table></figure><h4 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h4><p><code>print</code> 函数为输出Python程序的值提供了一种非常简便的方法。它接受零个或者多个参数，并且将单个空格作为默认分隔符来显示结果。通过设置<code>sep</code> 这一实际参数可<strong>以改变分隔符</strong>。此外，每一次打印都默认以<strong>换行符结尾</strong>。这一行为可以通过设置实际参数<code>end</code> 来更改。下面是一些例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;Hello&quot;)</span><br><span class="line">Hello</span><br><span class="line">&gt;&gt;&gt; print(&quot;Hello&quot;,&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">&gt;&gt;&gt; print(&quot;Hello&quot;,&quot;World&quot;, sep=&quot;***&quot;)</span><br><span class="line">Hello***World</span><br><span class="line">&gt;&gt;&gt; print(&quot;Hello&quot;,&quot;World&quot;, end=&quot;***&quot;)</span><br><span class="line">Hello World***&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="格式化运算符"><a href="#格式化运算符" class="headerlink" title="格式化运算符"></a>格式化运算符</h4><p>格式化字符串是一个模板，其中包含保持不变的单词或空格，但是年龄名字会根据运行变量变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;%s is %d years old.&quot; % (aName, age))</span><br></pre></td></tr></table></figure><p>%是字符串运算符，称为格式化运算符，表达式左边是模板，邮编是用于格式化字符串的值，邮编的值的格式与格式化字符串中的%的个数一致，这些值将依次从左到右地被换入格式化字符串中。</p><p>格式化字符串包含一个或多个转换声明，转换字符告诉格式化运算符，什么类型的值会被插入到字符串中的相应位置，在上面%s声明了一个字符串，%d声明了一个整数</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412112632124.png" alt="image-20230412112632124"></p><p>在%和格式化字符之间加入一个格式化修改符，可以根据给定的宽度进行左对齐或者右对齐，也可以通过小数点之后的一些数字来之指定宽度</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412112741940.png" alt="image-20230412112741940"></p><p>格式化运算符的邮编是被插入格式化字符串的一些值，这个集合可以是元组或者字典，如果是元组则根据位置次序插入，如果是字典，那么根据对应的简直插入，并且所有格式化字符串必须使用nae修改符号来指定键名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; price = 24</span><br><span class="line">&gt;&gt;&gt; item = &quot;banana&quot;</span><br><span class="line">&gt;&gt;&gt; print(&quot;The %s costs %d cents&quot; % (item,price))</span><br><span class="line">The banana costs 24 cents</span><br><span class="line">&gt;&gt;&gt; print(&quot;The %+10s costs %5.2f cents&quot; % (item,price))</span><br><span class="line">The     banana costs 24.00 cents</span><br><span class="line">&gt;&gt;&gt; print(&quot;The %+10s costs %10.2f cents&quot; % (item,price))</span><br><span class="line">The     banana costs     24.00 cents</span><br><span class="line">&gt;&gt;&gt; itemdict = &#123;&quot;item&quot;:&quot;banana&quot;,&quot;cost&quot;:24&#125;</span><br><span class="line">&gt;&gt;&gt; print(&quot;The %(item)s costs %(cost)7.1f cents&quot; % itemdict)</span><br><span class="line">The banana costs    24.0 cents</span><br></pre></td></tr></table></figure><p>Python的字符串还包含了一个<code>format</code> 方法。该方法可以与新的<code>Formatter</code> 类结合起来使用，从而实现复杂字符串的格式化。可以在Python参考手册中找到更多关于这些特性的内容。</p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>在给定条件位true时无限循环。</p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>用于遍历一个序列集合的每个成员</p><p><code>for</code> 语句的另一个非常有用的使用场景是处理字符串中的每一个字符。</p><h4 id="列表解析式"><a href="#列表解析式" class="headerlink" title="列表解析式"></a>列表解析式</h4><p>列表可以通过迭代结构和分支结构来创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sqlist = [x*x for x in range(1,11)]</span><br><span class="line">&gt;&gt;&gt; sqlist</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>变量<code>x</code> 会依次取由<code>for</code> 语句指定的1到10为值。之后，计算<code>x*x</code> 的值并将结果添加到正在构建的列表中。列表解析式也允许添加一个分支语句来控制添加到列表中的元素，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sqlist = [x*x for x in range(1,11) if x%2 != 0]</span><br><span class="line">&gt;&gt;&gt; sqlist</span><br><span class="line">[1, 9, 25, 49, 81]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在编程中常遇到语法错误或者逻辑错误，这些称为异常</p><p>党异常发生我们称抛出异常，可以用try来处理</p><p>try语句调用print来处理异常，对应的except遇见捕捉这个异常</p><p>例如，以下代码段要求用户输入一个整数，然后从数学库中调用平方根函数。如果用户输入了一个大于或等于0的值，那么其平方根就会被打印出来。但是，如果用户输入了一个负数，平方根函数就会报告<code>ValueError</code> 异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; anumber = int(input(&quot;Please enter an integer &quot;))</span><br><span class="line">Please enter an integer -23</span><br><span class="line">&gt;&gt;&gt; print(math.sqrt(anumber))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#102&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(math.sqrt(anumber))</span><br><span class="line">ValueError: math domain error</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>except</code> 会捕捉到<code>sqrt</code> 抛出的异常并打印提示消息，然后会使用对应数字的绝对值来保证<code>sqrt</code> 的参数非负。这意味着程序并不会终止，而是继续执行后续语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">       print(math.sqrt(anumber))</span><br><span class="line">    except:</span><br><span class="line">       print(&quot;Bad Value for square root&quot;)</span><br><span class="line">       print(&quot;Using absolute value instead&quot;)</span><br><span class="line">       print(math.sqrt(abs(anumber)))</span><br><span class="line"></span><br><span class="line">Bad Value for square root</span><br><span class="line">Using absolute value instead</span><br><span class="line">4.79583152331</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>def 函数()，可以通过这个隐藏计算细节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(n):</span><br><span class="line">...    return n**2</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; square(square(3))</span><br><span class="line">81</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>每当需要实现抽象数据类型时，就可以创建新的类</p><h4 id="Fractioni类"><a href="#Fractioni类" class="headerlink" title="Fractioni类"></a>Fractioni类</h4><p>Fraction 类是 Python 标准库中的一个类，用于表示分数。Fraction 类可以将分数表示为一个分子和一个分母的元组，同时还提供了一系列方法，用于对分数进行运算。</p><p>重现部分功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>:<span class="comment">#定义一个类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, top, bottom</span>): <span class="comment">#定义一个构造方法</span></span><br><span class="line">        <span class="comment">#self 是一个总是指向对象本身的特殊参数，它必须是第一个形式参数。然而，在调用方法时，从来不需要提供相应的实际参数。</span></span><br><span class="line">        self.num = top</span><br><span class="line">        self.den = bottom</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>): <span class="comment">#定义一个show方法使得fraction对象能够将自己作为字符串打印</span></span><br><span class="line">        <span class="built_in">print</span>(self.num,<span class="string">&quot;/&quot;</span>,self.den)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="comment">#重写将对象转化位字符串的方法__str__，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.num)+<span class="string">&quot;/&quot;</span>+<span class="built_in">str</span>(self.den)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="keyword">while</span> m % n != <span class="number">0</span>:</span><br><span class="line">            oldm = m</span><br><span class="line">            oldn = n</span><br><span class="line"></span><br><span class="line">            m = oldn</span><br><span class="line">            n = oldm % oldn</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, otherfraction</span>):</span><br><span class="line">        newnum = self.num*otherfraction.den + self.den * otherfraction.num</span><br><span class="line">        newden = self.den * otherfraction.den</span><br><span class="line">        common = self.gcd(newnum, newden)</span><br><span class="line">        <span class="keyword">return</span> self.__class__(newnum//common, newden//common)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m1 = Fraction(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">m2 = Fraction(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(m1+m2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412133414510.png" alt="image-20230412133414510"></p><h4 id="继承：逻辑门与电路"><a href="#继承：逻辑门与电路" class="headerlink" title="继承：逻辑门与电路"></a>继承：逻辑门与电路</h4><p>继承：使一个类与另一个类相关联，python中的子类可以从父类继承特征数据和行为。父类也称为<strong>超类</strong>。</p><p>下图的结构称为继承层次结构</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412133603619.png" alt="image-20230412133603619"></p><p>列表是有序集合的子，因此，我们将列表称为子，有序集合称为父（或者分别称为子类列表和超类序列）。这种关系通常被称为<strong>IS-A关系</strong> （IS-A意即列表<em>是一个</em> 有序集合）。</p><p>实现下面这个</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230412134506693.png" alt="image-20230412134506693"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class LogicGate:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.label = n</span><br><span class="line">        self.output = None</span><br><span class="line"></span><br><span class="line">    def getLabel(self): #逻辑门标签</span><br><span class="line">        return self.label</span><br><span class="line"></span><br><span class="line">    def getOutput(self): #逻辑门输出</span><br><span class="line">        self.output = self.performGateLogic()</span><br><span class="line">        return self.output</span><br><span class="line"></span><br><span class="line">class BinaryGate(LogicGate):</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super().__init__(n)</span><br><span class="line">        self.pinA = None</span><br><span class="line">        self.pinB = None</span><br><span class="line"></span><br><span class="line">    def getPinA(self):</span><br><span class="line">        return int(input(&quot;Enter Pin A input for gate &quot; + self.getLabel() + &quot;--&gt;&quot;))</span><br><span class="line"></span><br><span class="line">    def getPinB(self):</span><br><span class="line">        return int(input(&quot;Enter Pin B input for gate &quot; + self.getLabel() + &quot;--&gt;&quot;))</span><br><span class="line"></span><br><span class="line">class UnaryGate(LogicGate):</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super().__init__(n)</span><br><span class="line">        self.pin = None</span><br><span class="line">        </span><br><span class="line">    def getPin(self):</span><br><span class="line">        return int(input(&quot;Enter pin input for gate&quot; + self.getLabel()+&quot;--&gt;&quot;))</span><br><span class="line">    </span><br><span class="line">class AndGate(BinaryGate):</span><br><span class="line"></span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super().__init__(n)</span><br><span class="line"></span><br><span class="line">    def performGateLogic(self):</span><br><span class="line"></span><br><span class="line">        a = self.getPinA()</span><br><span class="line">        b = self.getPinB()</span><br><span class="line">        if a==1 and b==1:</span><br><span class="line">            return 1</span><br><span class="line">        else:</span><br><span class="line">          return 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法-Algorithm"><a href="#算法-Algorithm" class="headerlink" title="算法(Algorithm)"></a>算法(Algorithm)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>根据 Donald Knuth 的定义，算法（Algorithm）是指解决问题的一系列步骤，这些步骤按照一定的顺序执行，每个步骤都可以在有限的时间内完成，并能够产生某种输出结果。</p><p>另一位著名的计算机科学家 Thomas H. Cormen 等人给出的定义是，算法是一种精确定义的、确定性的、有效的、可行的、有穷的方法，用来解决特定问题的计算过程。</p><p>这两个定义都强调了算法必须具有准确的描述和明确的执行过程，而且必须能够在有限的时间内产生正确的输出结果。同时，算法也应该能够处理各种情况并能够适应不同规模的数据输入。</p><p>算法是为逐步解决问题而设计的一系列通用指令。给定某个输入，算法能得到对应的结果——算法就是解决问题的方法。</p><p>程序则是用某种编程语言对算法编码。同一个算法可以对应许多程序，这取决于程序员和编程语言。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>确定性：算法中的每个步骤都必须是精确而明确的，不会产生歧义或二义性。</li><li>有限性：算法必须在有限的时间内运行结束，不能无限制地执行下去。</li><li>输入：算法需要接收数据输入，并且必须能够处理各种情况和异常情况。</li><li>输出：算法应该能够产生输出结果，这个结果应该符合问题的要求和需求。</li><li>可行性：算法应该是可行的，即能够被实现并能够在给定的计算机环境下运行。</li><li>稳定性：算法应该能够在不同的输入数据下得到相同的输出结果，避免因输入数据的变化导致程序的错误。</li><li>高效性：算法应该尽可能高效，能够在较短的时间内执行完毕，并且占用较少的计算资源。</li><li>独立性：算法应该是独立的，即不受具体实现方式和编程语言的限制。</li></ol><h3 id="计算资源"><a href="#计算资源" class="headerlink" title="计算资源"></a>计算资源</h3><h3 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a>大O记法</h3><ol><li><p>大O记法是用来描述算法效率的一种数学符号，通常用于衡量算法时间复杂度的上限。时间复杂度是一个函数f(n)，表示算法执行的基本操作次数随着输入规模n的增加而增长的趋势。</p><p>常见的时间复杂度有：</p><ol><li>常数时间复杂度（O(1)）</li><li>对数时间复杂度（O(log n)）</li><li>线性时间复杂度（O(n)）</li><li>线性对数时间复杂度（O(n log n)）</li><li>平方时间复杂度（O(n^2)）</li><li>指数时间复杂度（O(2^n)）</li><li>阶乘时间复杂度（O(n!)）</li></ol><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413102103310.png" alt="image-20230413102103310"></p><p>算法性能有时不依赖于问题规模，还依赖于数据值。对于这种算法要用最坏情况、最好情况、普通情况来描述性能。</p><p>在计算时间复杂度时，我们通常考虑输入数据规模n对于算法运行时间的影响。因此，时间复杂度是一个函数f(n)，表示算法执行的基本操作次数随着输入规模n的增加而增长的趋势。一般情况下，我们会将算法中最耗时的操作（通常是循环）的运行次数作为时间复杂度的基础。</p><p>需要注意的是，时间复杂度是一个渐进复杂度，即当n趋近于无穷大时，算法的运行时间会趋近于时间复杂度所代表的数量级。同时，时间复杂度只描述算法的执行时间，不考虑空间复杂度和其他因素。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n)=5n^2 + 27n + 1005</span><br></pre></td></tr></table></figure><p>例如这个例子，当n无限大时可以忽略其他留下影响最大的5n^2,当n再大系数5也没用了，所以f(n)&#x3D;n^2,也可以写为O(n^2)</p><h3 id="python数据结构的性能"><a href="#python数据结构的性能" class="headerlink" title="python数据结构的性能"></a>python数据结构的性能</h3><h4 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h4><p>最常见的操作时索引和给某个位置赋值，无论列表长度这两个操作的所花的时间应该是恒定的。像这种与列表长度无关的操作就是常数阶的。O(1)</p><p>另一个常见操作时加长列表，由两种方式，要么追加，要么连接。追加方法是常数阶的。如果连接列表长度为k那么操作的时间复杂度就是O(K)</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413103654621.png" alt="image-20230413103654621"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413103950881.png" alt="image-20230413103950881"></p><h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/image-20230413104118461.png" alt="image-20230413104118461"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily_English</title>
      <link href="/undefineddaily/"/>
      <url>/undefineddaily/</url>
      
        <content type="html"><![CDATA[<h1 id="read"><a href="#read" class="headerlink" title="read"></a>read</h1><h2 id="2023年3月21日"><a href="#2023年3月21日" class="headerlink" title="2023年3月21日"></a>2023年3月21日</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The Benefits of Reading</span><br><span class="line"></span><br><span class="line">Reading is one of the best ways to improve your language skills, expand your vocabulary, and gain knowledge. It **not only** helps you with your academic studies **but also** enhances your personal development.</span><br><span class="line"></span><br><span class="line">By reading regularly, you can learn new words and phrases, which will help you express yourself more accurately and precisely in both spoken and written English. Additionally, reading exposes you to different sentence structures and writing styles, allowing you to absorb the flow of language and develop a sense of how to use it effectively.</span><br><span class="line"></span><br><span class="line">Moreover, reading provides many benefits beyond language learning. For example, reading can broaden your horizons, cultivate your imagination, and reduce stress levels. It can also improve your focus and concentration, as well as enhance your critical thinking and problem-solving abilities.</span><br><span class="line"></span><br><span class="line">Therefore, if you want to improve your English proficiency and overall development, make sure to incorporate reading into your daily routine. Whether it&#x27;s a novel, a news article, or a blog post, choose something that interests you, and enjoy the many benefits that reading can offer.</span><br></pre></td></tr></table></figure><p>the best ways (最好的方法)；expand(扩大)；vocabulary(词汇)；gain(获得)；your academic studies(你的学术研究中)；enhances(提高)；development(发展)；regularly(规律)；phrases(短语)，accurately(正确的)，precisely(准确的)；“by”表示通过某种方式或手段；“reading regularly”则表示定期阅读；Additionally(进一步，另外)；expose(暴露、接触)；sentence(句子)；structures(结构)；styles(方式)；allowing(现在分词，表示允许、使得)；absorb(吸收，理解，掌握)；“the flow of language”表示语言的流畅性、韵律；sense(感觉，认识，理解力)；effectively(有效地，事实上)；moreover(而且)；benefits(好处，利益)；provide(提供、供应)；beyond(更加深处、超出范围、超越)；broden(扩大、扩张)；horizons(地平线、眼界)；cultivate(种植、培养)；imagination(想象力)；reduce(减少)；stress(压力、紧张)；levels(水平、层次)；focus(聚焦、关注)；concentrate(集中、浓缩)；critical(批判的、危急的、极端的、重要的)；critical thinking(批判思维)；abilities(特殊能力、技能)；solving(解决、处理)；therefore(表达上文提到的内容的结果)；proficiency(熟练)；overall(全面来看，总体上)；make sure(确保)；incorporate(整合、合并)；routine(惯例)；whether(即使、无论到什么程度也会发生某个事情)；novel(小说、独特的事物、通常被认为是文学的高级形式)；Whether it’s a novel, a news article， or a blog post(无论它是高级文学、新闻或者博客文章)；offer(提供、给予)；can(能力、许可行、可能性，描述一种行为或状态是否可能发生)</p><ol><li>“which will help you express yourself more accurately and precisely”是一个从句，用来进一步解释前面的陈述。其中，“which”引导了一个非限定性定语从句，修饰“new words and phrases”，表示这些新的单词和短语将帮助你更准确地表达自己。</li><li>“in both spoken and written English”是一个介词短语，用来说明应用范围，即你可以在口语和书面语中都能够更好地表达自己。使用“both”可以强调两种语言形式之间的相似性和重要性，并且更自然地表达意思。</li><li>“exposes you to different sentence structures and writing styles”是一个复合谓语，由动词“exposes”和其后面的两个介词短语组成。其中，“exposes”表示暴露、接触的意思，后面的“you”是宾语，“to different sentence structures and writing styles”则是介词短语，用来说明接触的内容。换句话说，阅读可以让你接触不同的句子结构和写作风格。</li><li>“allowing you to absorb the flow of language”中，“allowing”是一个现在分词，表示允许、使得的意思，它与主句之间使用逗号隔开。而“you”则是动词“allowing”的宾语，“to absorb the flow of language”则是一个不定式短语，用来说明所允许的结果。具体来说，“absorb”表示吸收、掌握的意思，“the flow of language”表示语言的流畅性、韵律等等。</li><li>“and develop a sense of how to use it effectively”是另一个不定式短语，用来进一步解释之前提到的结果。其中，“develop”表示发展、培养的意思，“a sense of how to use it effectively”表示如何有效地运用所学的内容，也就是语言技能的提升。</li><li>“choose something that interests you”在这个短语中，“that” 是一个引导从句的连词。从句是 “interests you”，其中“that”指代先行词“something”，表示选择感兴趣的东西。整个短语的意思是选择你感兴趣的东西，其目的是鼓励阅读者选择他们喜欢的阅读材料，并让阅读更具乐趣和有益性。</li></ol><h2 id="2023年3月22日"><a href="#2023年3月22日" class="headerlink" title="2023年3月22日"></a>2023年3月22日</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Healthy Habits for a Happy Life&quot;</span><br><span class="line"></span><br><span class="line">Leading a healthy lifestyle is crucial for a happy life. </span><br><span class="line">Some simple habits that can make a big difference include eating nutritious foods, getting enough sleep, exercising regularly, and managing stress. </span><br><span class="line">Taking care of our bodies and minds is important not only for our physical health, but also for our mental well-being. </span><br><span class="line">Let&#x27;s commit to making positive choices every day and live our best life!</span><br></pre></td></tr></table></figure><p>habits(习惯)，leading(领导)，lifestyle(生活方式)；nutritious(有营养的)；exercising(训练，行驶)；regularly(经常，有规律的，均匀)；managing(管理)；stress(压力，强调) ；taking care of(照顾、关心、照料)；bodies(身躯)；mind(心灵、头脑、思想)；mental(精神的、思想的)；well-being(幸福感、福利)；commit(投入、承诺、致力于)；positive(积极的、肯定的、正面的)；best(最好的)；live(生活、存在、居住、描述某方式或状态的存在)</p><p>这句话是由一个主语“Some simple habits”和一个谓语“include”组成的简单句。其中，“simple habits”是主语，表示“简单的习惯”，紧接着用“that”引导一个定语从句来进一步详细说明这些习惯的特点。“that can make a big difference”是定语从句，修饰“simple habits”，表达“可以产生很大影响”的意思。</p><p>在定语从句中，有四个并列的动词短语，分别是“eating nutritious foods”、“getting enough sleep”、“exercising regularly”和“managing stress”。它们以逗号分隔，形成了一个并列结构。每个动词短语都包含一个现在分词作为其核心部分，并且都表示一个健康习惯，具体地阐述了“simple habits”的内容。</p><h2 id="2023年3月23日"><a href="#2023年3月23日" class="headerlink" title="2023年3月23日"></a>2023年3月23日</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. BAEL</span><br><span class="line">Bael can be pronounced as BAH-ELL, BAHL or BAIL.</span><br><span class="line">The Powers of Bael</span><br><span class="line">To remain unseen when you would otherwise be noticed.</span><br><span class="line">保持不被发现当你本应该被注意到的情况下</span><br><span class="line">To make somebody lose interest in you and your affairs.</span><br><span class="line">在你和你的事业上让某些人对你失去兴趣</span><br><span class="line">To bring confusion and torment to anybody who enquires about a subject that you wish to remain hidden.</span><br><span class="line">对于任何询问这个人不希望透露的信息带来混论和折磨</span><br><span class="line">To make a thing or situation to appear as something other than it is.</span><br><span class="line">让某个事物或情况看起来和实际不同。</span><br><span class="line">To compel others to keep secrets for you.</span><br><span class="line">强迫他人为你保守秘密。</span><br><span class="line">This applies to friends who need encouragement to remain quiet and foes who must be silenced.</span><br><span class="line">这适用于需要鼓励保持沉默的朋友和必须被制止的敌人</span><br><span class="line">The Evocation Keys of Bael</span><br><span class="line">唤醒贝尔的密钥</span><br><span class="line">Bael is associated with dark, shifting colors and textures, with an earthy senseof roughness. There is a scent of bark, soil, and blood. Sounds include therumble of thunder and fierce gusts. There is a bitter taste.</span><br><span class="line">贝尔的形象和特点通常呈现出深色、模糊或变幻的颜色和纹理，并且带有一种强烈的地球元素或粗糙感觉。此外，还有一股树皮、土壤和血液的气味，以及雷声和强风等声音。最后，还有一种苦涩的味道。</span><br><span class="line">The Conjuration of Bael</span><br><span class="line">The Shem Angel: Vehuel (VEH-WHO-ELL)</span><br><span class="line">Invocation Psalm 3:3</span><br><span class="line">VEH-AH-TAH AH-DOH-NIGH MAH-GEN</span><br><span class="line">BAH-AH-DEE KEH-VAW-DEE</span><br><span class="line">OO-MAY-REEM RAW-SHE</span><br><span class="line">The Angelic Emissaries</span><br><span class="line">Vavliel (VAH-VEH-LEE-YELL)</span><br><span class="line">Hoel (HAW-ELL)</span><br><span class="line">Venael (VEH-NA-ELL)</span><br></pre></td></tr></table></figure><p>remain(保持不变、留下)；unseen(未见过、未曾发现、不为人知)；otherwise(否则、要不然)；notice(通知、公告、通告)；”Would” 是助动词，表示条件或假设；affairs(个人、组织、公司等方面的事务或事宜)；bring(带来、取来、引起)；confusion(混乱、困惑、糊涂)；torment(折磨、煎熬、苦难);enquire(询问)；hidden(隐藏，隐蔽)；ting(事情、东西)；situation(状况)；appear(显得、看上去)；”as” 表示“作为”或“成为”；”as” 表示“作为”或“成为”；other than” 表示除了、不同于；”it is” 意思是其本身的状态或真实情况。”to compel” 意味着强迫、迫使；encouragement(鼓励)；quiet(冷静、平静)；foes(敌人、仇敌)；silenced(使安静)；evocation(唤起；引起)；”associated with” 表示“与…相关联”；”dark” 意味着黑暗、昏暗；”shifting” 意味着不断变化或变幻；”colors and textures” 意味着颜色和纹理；”earthy sense” 意味着土壤般的感觉。 roughness（粗糙的）；</p><ol><li>“would be noticed” 表示“本应该被注意到”，这里的 “would” 用来表示一种假设或可能性；</li><li>“otherwise” 表示“否则”，引出这个假设的情况。</li><li>“to make” 意思是制造、创造、使得；</li><li>as something other than it is” 意思是成为与实际不同的事物。</li></ol><h2 id="2023年3月26日"><a href="#2023年3月26日" class="headerlink" title="2023年3月26日"></a>2023年3月26日</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Title: Tips for Effective Time Management</span><br><span class="line"></span><br><span class="line">Effective time management is crucial for success. Prioritize your tasks by importance and urgency, use a schedule or planner to organize your day, and eliminate distractions. Remember to take breaks and reward yourself for completing tasks. Good time management leads to increased productivity and less stress.</span><br></pre></td></tr></table></figure><p>effective（能够产生预期或意图中的结果，成功的）；crucial(非常重要或关键的)；prioritize（按重要性排序）；urgency（紧急）；schedule（计划或时间表）；panner（用于记录或者安排未来活动的工具）organize（安排或组织事物）；eliminate(消除或除去)；distracted（分散注意力或者无法让人集中精力的食物或者因素）；reward（一种激励来鼓励或奖励某人完成任务的东西）；Remember to take breaks（记得休息）；Increased增加或提高。Productivity效率。less stress(&#x2F;更少的紧张或者焦虑)</p><ol><li>句子结构：该文章采用简单句和复合句结合的方式进行表达。简单句包括一个主语和一个谓语，如“Remember to take breaks.”。复合句包括一个主句和一个或多个从句，如“Effective time management is crucial for success.”和“Prioritize your tasks by importance and urgency, use a schedule or planner to organize your day, and eliminate distractions.”</li><li>动词时态：文章中使用了现在时来表达普遍真理和日常习惯，如“Effective time management is crucial for success.”和“Remember to take breaks.”。同时也使用了现在进行时来表示正在发生的动作或状态，如“use a schedule or planner to organize your day”和“reward yourself for completing tasks。”</li><li>介词短语：文章中使用了一些介词短语来修饰名词或动词，如“by importance and urgency”、“for completing tasks”和“of activities”。</li><li>形容词和副词：文章中使用了形容词和副词来修饰名词和动词，如“effective time management”、“crucial for success”和“less stress”。</li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h4><p>谓语（predicate）是句子中的一个重要成分，用来描述主语所表达的动作、状态或属性。在简单句中，谓语通常由一个谓语动词和可能的其他成分组成，例如宾语、宾语补足语、状语等等。</p><p>谓语动词表示主语的动作、状态或属性，并在句子中充当主语和其他成分之间的连接词。谓语动词可根据时态、语态、人称和数等变化，以适应不同的语境和语言习惯。例如：</p><ul><li>She sings beautifully.（她唱歌唱得很好听。）这里，“sings”是谓语动词，表示主语“she”正在进行的动作。</li><li>The movie was watched by many people.（这部电影被许多人观看了。）这里，“was watched”是谓语动词，表示主语“the movie”的状态或经历。</li><li>I will go to the party tonight.（今晚我会去参加聚会。）这里，“will go”是谓语动词，表示主语“I”打算在未来进行的动作。</li></ul><p>需要注意的是，谓语并不仅仅包括谓语动词，它还可能包括其他成分，如宾语、宾语补足语和状语等。谓语结构的完整性和正确性对于表达清晰、准确的意思非常重要。</p><h5 id="谓语动词"><a href="#谓语动词" class="headerlink" title="谓语动词"></a>谓语动词</h5><p>“谓语动词”指的是一种用来说明主语所做的动作或具有的状态的动词。在一个简单句中，谓语动词通常位于句子的谓语部分，它可以使整个句子具备陈述句、疑问句、祈使句等不同的语气和语态。</p><p>例如，以下句子中的谓语动词分别表示不同的动作或状态：</p><ul><li>She sings beautifully.（她唱歌唱得很好听。）</li><li>They are sleeping now.（他们现在正在睡觉。）</li><li>He will come tomorrow.（他明天会来。）</li></ul><h5 id="复合谓语"><a href="#复合谓语" class="headerlink" title="复合谓语"></a>复合谓语</h5><p>复合谓语（compound predicate）是一个包含两个或多个谓语的谓语结构，用来描述主语的多种动作或状态。具体地说，它由一个主谓结构和至少一个附加谓语组成，其中主谓结构表示动作或状态的主要信息，而附加谓语则表示与主谓结构相关、但又独立于其它动作或状态的信息。</p><p>常见的复合谓语包括以下几种形式：</p><ol><li>同时使用两个动词作为谓语，例如：“He laughed and clapped his hands.”（他笑了起来，还拍了拍手。）这里，“laughed”和“clapped”都是动词，它们共同构成了复合谓语，用来描述主语的两种动作。</li><li>使用一个动词和一个形容词或副词作为谓语，例如：“She danced gracefully across the stage.”（她优美地跳过舞台。）这里，“danced”是主谓结构，表示跳舞这个动作，而“gracefully”是附加谓语，表示跳舞时的状态和方式。</li><li>使用一个动词和一个介词短语作为谓语，例如：“He walked to the store and bought some milk.”（他走到商店买了些牛奶。）这里，“walked”是主谓结构，表示走路这个动作，而“to the store and bought some milk”是附加谓语，表示走路时的目的地和后续行动。</li></ol><p>需要注意的是，复合谓语的使用可以丰富语言表达，增强句子的信息量和意义。在使用复合谓语时，需要保证各个谓语之间的逻辑关系清晰，并且确保句子的结构和语法正确。</p><h4 id="连系动词"><a href="#连系动词" class="headerlink" title="连系动词"></a>连系动词</h4><p>“连系动词”（linking verb）是一种用来连接主语和表语（补足语）的动词。它不表示动作或行为，而是用来描述或说明主语的状态、感觉、特征等内容，通常出现在句子的谓语部分。</p><p>常见的连系动词包括be动词（如is, am, are, was, were）、感官动词（如look, sound, smell, taste, feel）、变化动词（如become, turn, grow, get, remain）等。例如：</p><ul><li>She is a doctor.（她是一名医生。）</li><li>The soup smells delicious.（这汤闻起来很香。）</li><li>He became very angry.（他变得非常生气。）</li></ul><p>需要注意的是，有些动词既可以作为谓语动词，也可以作为连系动词，这取决于它们在句子中的用法。比如，“look”在表示看的动作时是谓语动词，“look”在表示看起来的状态时则是连系动词。例如：</p><ul><li>She looks at the book.（她看着这本书。）- 谓语动词</li><li>She looks unhappy.（她看起来不高兴。）- 连系动词</li></ul><h4 id="表语（补足语）"><a href="#表语（补足语）" class="headerlink" title="表语（补足语）"></a>表语（补足语）</h4><p>“表语”（predicate complement）是指用来补充说明主语的状态、性质、特征等内容的词或短语。它通常紧跟在连系动词之后，用来进一步描述主语。</p><p>例如，在句子“She is a doctor.”中，“is”是连系动词，而“a doctor”则是表语，表示主语“she”的身份或职业。再比如，在句子“I feel tired today.”中，“feel”是感官动词，而“tired”则是表语，表示主语“我”今天的状态。</p><p>需要注意的是，有些动词既可以作为及物动词，也可以作为连系动词，这时它们后面可以跟宾语或表语。在前者中，动词的宾语承担了动作的接受者或目标；在后者中，表语则进一步描述了主语的属性或状态。例如：</p><ul><li>They made him captain.（他们让他成为了队长。）- “him”是动词“made”的宾语。</li><li>She seems very happy.（她看起来非常高兴。）- “very happy”是连系动词“seems”的表语。</li></ul><h4 id="从句"><a href="#从句" class="headerlink" title="从句"></a>从句</h4><p>从句（subordinate clause）指的是一个不能独立成为完整句子的句子，它必须依附在主句中才能完成自己的语法功能。从句通常包括一个主语和一个谓语，但由于缺乏某些要素，如主句所需的主语或谓语、标点等，不能单独存在。</p><p>从句可以用来修饰名词、形容词、副词等，起到进一步解释、说明、补充主句内容的作用。根据从句与主句的关系，从句可以分为三类：名词性从句、形容词性从句和副词性从句。</p><p>常见的从句有：</p><ol><li>名词性从句：用来充当名词，在句中可以代替一个名词。例如：“What he said was very interesting.”（他说的话很有趣。）</li><li>形容词性从句：用来修饰名词或代词，在句中充当形容词。例如：“The book that I borrowed from the library is on the desk.”（我从图书馆借来的那本书在桌子上。）</li><li>副词性从句：用来修饰动词、形容词或副词，在句中充当副词。例如：“She sings as if she were a bird.”（她唱歌就像一只鸟儿。）</li></ol><h5 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h5><p>非限定性定语从句（non-defining relative clause）是一种修饰名词或代词的句子，用来进一步描述这个名词或代词。与限定性定语从句不同的是，非限定性定语从句与主句之间没有必要的关系，即去掉从句对主句意义的影响较小。</p><p>非限定性定语从句通常由一个关系代词（如who, whom, whose, which, that）引导，但也可以用其他关系词、介词短语等来引导。例如：</p><ul><li>My friend Jack, who lives in New York, is coming to visit me.（我的朋友杰克，住在纽约，要来看我。）</li><li>The book, which I read last week, was very interesting.（上周我读的那本书非常有趣。）</li></ul><p>需要注意的是，非限定性定语从句通常用逗号与主句分开，以区别于限定性定语从句。此外，非限定性定语从句中的关系代词在从句中往往包含了更多的信息，如陈述事实、强调特点等。</p><h4 id="分句"><a href="#分句" class="headerlink" title="分句"></a>分句</h4><p>分句是一个句子中的较小独立单元，通常包含一个主题、主语和谓语等要素。它可以作为完整的句子，也可以作为更长复杂句子的一部分。分句通常由一个或多个从句和主句组成。</p><p>常见的分句类型包括：</p><ol><li>主句（main clause）：独立的完整句子，能够单独存在并传达意思。</li><li>从句（dependent clause）：不能独立存在的句子，需要依赖主句才能构成完整的句子。</li><li>并列句（compound sentence）：由两个或多个主句组成的句子，通过连接词如“and”、“or”、“but”等相互联系。</li><li>复合句（complex sentence）：由一个主句和一个或多个从句组成的句子，其中从句扮演更加详细的角色和功能。</li></ol><p>以下是一些例子：</p><ul><li>“I went to the store, and I bought some milk.”（我去了商店，然后我买了些牛奶。）这是一个并列句，由两个主句组成，用逗号和连词“and”相连。</li><li>“When I got home, I realized that I had left my keys at work.”（当我回到家时，我意识到我的钥匙落在了办公室。）这是一个复合句，由一个主句和一个时间状语从句组成，从句由引导词“when”开头。</li><li>“Although she was tired, she decided to go for a run.”（虽然她很累，但她还是决定去跑步。）这是一个复合句，由一个主句和一个条件从句组成，从句由引导词“although”开头。</li><li>“He lost his phone, which caused him to panic.”（他把手机丢失了，这使他陷入恐慌。）这是一个复合句，由一个主句和一个关系从句组成，从句由关系代词“which”引导。</li></ul><h4 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h4><p>副词（adverb）是一种用来修饰动词、形容词、其他副词或整个句子的词类。它可以表示时间、地点、程度、方式、原因等概念，用来进一步描述所修饰的词或短语。</p><p>常见的副词包括：quickly（快速地）、suddenly（突然地）、carefully（小心地）、often（经常）、there（在那里）、almost（几乎）、very（非常）、too（太）、never（从不）等。</p><p>使用副词时需要注意以下几点：</p><ol><li>副词通常放在动词之后，形容词或其他副词之前，用来修饰它们。例如：“She sings beautifully.”（她唱歌唱得很好听。）</li><li>特别的副词须放在某些位置，如疑问句中应将状语置于主语后面，否则应置于句首或句末位置。例如：“Where have you been?”（你去哪里了？）和“Certainly, I will go with you.”（当然了，我会和你一起去的。）</li><li>有些副词具有两个或更多意思，具体意思需要根据上下文和语境判断。例如，“He hardly eats anything.”（他几乎什么都不吃。）和“He could hardly believe his eyes.”（他几乎不敢相信自己的眼睛。）</li></ol><h4 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h4><p>介词（preposition）是一种连接词，用于表示名词、代词或其他词与其它单词之间的关系，如时间、地点、方向、方式等。介词通常放在名词或代词前面，构成介词短语。</p><p>常见的英语介词包括：in, on, at, to, for, with, by, from, of, about, between, among等。例如：</p><ul><li>The book is on the table.（这本书在桌子上。）</li><li>She walked to the store.（她走到商店。）</li><li>I’m going to the beach with my friends.（我和我的朋友们一起去海滩。）</li></ul><p>需要注意的是，介词的使用需要根据上下文和语境来确定。不同的介词可以有不同的含义和用法，而同一个介词在不同的情况下也可能具有不同的含义和用法。因此，在学习和使用介词时，需要注意其具体的语境和含义，以避免使用错误或造成歧义。</p><h5 id="介词短语"><a href="#介词短语" class="headerlink" title="介词短语"></a>介词短语</h5><p>介词短语（prepositional phrase）是由一个介词和它后面的宾语组成的短语。介词短语通常用来表示时间、地点、方向、方式、原因等概念，用来进一步描述句子中的名词或代词。</p><p>介词短语可以在句子中担任多种语法角色，如修饰动词、形容词、副词或名词等。例如：</p><ul><li>We walked through the park.（我们穿过了公园。）- “through the park”是一个介词短语，用来修饰动词“walked”，表示通过某个地方。</li><li>The book on the table is mine.（桌子上的那本书是我的。）- “on the table”是一个介词短语，用来修饰名词“book”，表示它的位置在桌子上。</li></ul><p>介词短语通常由一个介词和它所需的宾语构成，它们之间不需要其他成分。需要注意的是，介词短语的位置有时会影响句子的意思和语境。</p><h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><p>动词（verb）是一个表示动作、状态或存在的词类。它是句子中最重要的成分之一，用来描述主语所进行的动作、感受到的状态或者存在的情况。</p><p>动词可以用来表示过去、现在和将来，也可以用来表达各种情态，例如：</p><ul><li>过去式：I walked to school yesterday.（我昨天走路去学校了。）</li><li>现在式：She is eating breakfast right now.（她正在吃早餐。）</li><li>将来式：They will visit their grandparents next month.（他们下个月会去拜访他们的祖父母。）</li><li>情态动词：You should study hard for the exam.（你应该为考试努力学习。）</li></ul><p>动词也可以通过时态、语态、人称和数等形式变化，以适应不同的语境和语言习惯。例如：</p><ul><li>过去式：walked（过去式）</li><li>现在式：walks（第三人称单数现在式）</li><li>将来式：will walk（将来式）</li><li>完成时：has walked（完成时）</li></ul><p>需要注意的是，在句子中，动词通常需要与主语配合使用，构成主谓结构，如“Mary sings.”（玛丽唱歌。），其中“Mary”是主语，“sings”是谓语动词。动词还可以与其他成分组成复合谓语和短语，如“is walking to school”（正在走路去学校）和“likes playing soccer”（喜欢踢足球）。</p><h5 id="现在分词"><a href="#现在分词" class="headerlink" title="现在分词"></a>现在分词</h5><p>现在分词（present participle）是动词的一种形式，在构成进行时态、进行式和现在分词短语等结构中使用。它通常由动词原形加上-ing构成，例如：</p><ul><li>walking（走）</li><li>singing（唱歌）</li><li>playing（玩）</li></ul><p>现在分词可以用作动词的形式，表示正在进行的动作或状态，例如：</p><ul><li>She is walking to the store.（她正在步行去商店。）</li><li>They are playing basketball in the park.（他们正在公园里打篮球。）</li></ul><p>除了作为动词的形式外，现在分词还可以作为形容词或副词使用。作为形容词时，现在分词通常描述主语的特征或状态，例如：</p><ul><li>The crying baby needs to be fed.（哭闹的婴儿需要被喂食。）</li><li>The running water sounds so relaxing.（流淌的水声听起来很舒服。）</li></ul><p>作为副词时，现在分词通常表示伴随着动作的方式、原因或条件，例如：</p><ul><li>He drove to work listening to music.（他开车去上班时听着音乐。）</li><li>Being tired, she decided to go to bed early.（由于感到疲倦，她决定早点睡觉。）</li></ul><p>需要注意的是，现在分词的用法和功能非常灵活，具体的含义和用法可能需要根据上下文和语境来确定。</p><p>不定式（infinitive）是一个动词的非限定形式，通常由“to”以及动词原形构成。在句子中，不定式可以作为名词、形容词或副词使用。</p><p>不定式作为名词时，通常用来表示一个动作或状态的概念，例如：</p><ul><li>To learn a new language takes time.（学习一门新语言需要时间。）</li><li>My goal is to become a doctor.（我的目标是成为一名医生。）</li></ul><p>不定式作为形容词时，通常用来描述名词或代词所表示的人或事物的特征或性质，例如：</p><ul><li>I have a book to read.（我有一本要读的书。）</li><li>The decision to cancel the event was disappointing.（取消活动的决定令人失望。）</li></ul><p>不定式作为副词时，通常用来修饰动词、形容词、副词或整个句子，表示动作的目的、结果、条件、原因等，例如：</p><ul><li>She went to the store to buy some milk.（她去商店买牛奶。）</li><li>He was too tired to continue working.（他太累了，不能继续工作了。）</li><li>To be honest, I don’t like his attitude.（说实话，我不喜欢他的态度。）</li></ul><p>需要注意的是，不定式与动词的其他形式相比，它没有人称和数的变化，也没有时态的区别。同时，在不定式的前面加上助动词“will”可以表示将来时态，如“to meet”（遇见）可以变为“will meet”（将要遇见）。</p><h5 id="不定式"><a href="#不定式" class="headerlink" title="不定式"></a>不定式</h5><p>不定式（infinitive）是一个动词的非限定形式，通常由“to”以及动词原形构成。在句子中，不定式可以作为名词、形容词或副词使用。</p><p>不定式作为名词时，通常用来表示一个动作或状态的概念，例如：</p><ul><li>To learn a new language takes time.（学习一门新语言需要时间。）</li><li>My goal is to become a doctor.（我的目标是成为一名医生。）</li></ul><p>不定式作为形容词时，通常用来描述名词或代词所表示的人或事物的特征或性质，例如：</p><ul><li>I have a book to read.（我有一本要读的书。）</li><li>The decision to cancel the event was disappointing.（取消活动的决定令人失望。）</li></ul><p>不定式作为副词时，通常用来修饰动词、形容词、副词或整个句子，表示动作的目的、结果、条件、原因等，例如：</p><ul><li>She went to the store to buy some milk.（她去商店买牛奶。）</li><li>He was too tired to continue working.（他太累了，不能继续工作了。）</li><li>To be honest, I don’t like his attitude.（说实话，我不喜欢他的态度。）</li></ul><p>需要注意的是，不定式与动词的其他形式相比，它没有人称和数的变化，也没有时态的区别。同时，在不定式的前面加上助动词“will”可以表示将来时态，如“to meet”（遇见）可以变为“will meet”（将要遇见）。</p><h5 id="非限定形式"><a href="#非限定形式" class="headerlink" title="非限定形式"></a>非限定形式</h5><p>非限定形式（non-finite form）是指动词的某些形式，它们不具备人称、数和时态等语法特征，并且不能直接充当句子中的谓语动词。常见的非限定形式有不定式、动名词和现在分词。</p><p>与限定形式相对应的是限定形式（finite form），它具备人称、数和时态等语法特征，并且可以直接充当句子中的谓语动词。例如，在下列句子中，“is”和“was”就是限定形式：</p><ul><li>She is reading a book.（她正在读一本书。）</li><li>They were watching a movie.（他们正在看电影。）</li></ul><p>而在下列句子中，“to read”、“reading”和“watching”就是非限定形式：</p><ul><li>I want to read that book.（我想要读那本书。）</li><li>Reading a book is a good way to relax.（读书是一个好的放松方式。）</li><li>Watching movies is his favorite hobby.（看电影是他最喜欢的爱好。）</li></ul><p>需要注意的是，非限定形式在句子中通常充当名词、形容词或副词等其他成分的角色，用来修饰或补充句子的意思，例如作主语、宾语、表语、宾补和状语等。</p><h5 id="助动词"><a href="#助动词" class="headerlink" title="助动词"></a>助动词</h5><p>助动词（Auxiliary verbs）是一类用于构成各种时态、语态、否定句、疑问句等结构的特殊动词。它们通常与其他动词一起使用，以便表达更复杂的意义和信息。常见的助动词包括 be, do, have 等。</p><p>助动词可以用于以下几个方面：</p><ol><li>构成时态：助动词可以与主要动词一起构成各种时态，例如现在进行时、过去进行时、现在完成时等。</li><li>构成语态：助动词可以与主要动词一起构成被动语态或进行语态，例如现在进行时被动语态、过去进行时进行语态等。</li><li>构成否定句：助动词可以与 not 一起构成否定句，例如 “I do not like coffee”（我不喜欢咖啡）。</li><li>构成疑问句：助动词可以与主语互换位置，以构成疑问句，例如 “Do you like coffee?”（你喜欢咖啡吗？）。</li></ol><p>除了以上四个方面，助动词还可以用于强调、情态等方面，具体使用需要根据语境和需要来选择正确的助动词。</p><h5 id="情态动词"><a href="#情态动词" class="headerlink" title="情态动词"></a>情态动词</h5><p>情态动词是一类特殊的助动词，用于表示说话人的意愿、能力、必要性、建议、命令、猜测或可能性等语气和情态。常见的情态动词包括 can, could, may, might, must, shall, should, will, would 等。</p><p>情态动词通常与其他动词连用，形成各种不同的语法结构和意义。例如：</p><ol><li>表示能力或许可：</li></ol><ul><li>Can: 表示能力或许可(肯定)，例如 “I can swim”（我会游泳）或 “Can I borrow your pen?”（我可以借你的笔吗？）</li><li>Could: 过去式和虚拟语气(假设)，例如 “I could swim when I was young”（我小时候能游泳）或 “If I had more time, I could finish the project”（如果我有更多时间，我就能完成这个项目了）。</li></ul><ol><li>表示可能性或推测：</li></ol><ul><li>May&#x2F;Might: 表示可能性或推测，例如 “It may rain tomorrow”（明天可能下雨）或 “He might be late”（他可能会迟到）。</li></ul><ol><li>表示义务、建议或推荐：</li></ol><ul><li>Must: 表示强制性和义务，例如 “You must do your homework”（你必须做你的家庭作业）。</li><li>Should: 表示建议或推荐，例如 “You should exercise regularly”（你应该经常锻炼）。</li></ul><ol><li>表示意愿或请求：</li></ol><ul><li>Would: 表示意愿或请求，例如 “Would you like some tea?”（你想喝点茶吗？）</li></ul><p>需要注意的是，情态动词在使用时具有一定的语法规则和限制，例如不能被直接加-ing 或-ed 形式，都是用原形动词，并且后面的动词要用基础形式。此外，不同的情态动词也有自己的用法和习惯搭配，需要根据语境和需要选择正确的情态动词。</p><h4 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h4><p>连词是一类用于连接单词、短语或句子的词语。它们帮助将各种元素组合成更复杂的结构，并指示它们之间的关系。常见的连词包括：</p><ol><li>并列连词（coordinating conjunctions），如”and”、“or”、“but”等，用于连接平行的单词、短语或句子；</li><li>从属连词（subordinating conjunctions），如“if”、“when”、“because”等，用于引导从句并将其与主句连接起来；</li><li>连接副词（conjunctive adverbs），如“however”、“therefore”、“meanwhile”等，用于连接句子或段落。</li></ol><p>连词在英语中起到非常重要的作用，可以帮助我们构建清晰、有条理的句子和段落，并且使我们的表达更加准确和流畅。</p><h4 id="先行词"><a href="#先行词" class="headerlink" title="先行词"></a>先行词</h4><p>先行词是一个名词，指在句子中引导代词或关系从句的名词。代词和关系从句通常用来进一步说明或限定先行词。在句子中，先行词通常出现在代词或关系从句之前，并且它们的意思必须与代词或关系从句所描述的内容相符。</p><p>例如，在下面的句子中，“book” 就是先行词：</p><ul><li>“I borrowed a book from the library, and it was really interesting.”（我从图书馆借了一本书，它真的很有趣。）</li></ul><p>在这个例子中，”book” 是先行词，而 “it” 是代替 “book” 的代词。通过使用代词 “it”，我们可以避免反复提到 “book”，使句子更加简洁。</p><p>另一个例子是：</p><ul><li>“The woman who lives next door is a doctor.”（住在隔壁的那位女士是医生。）</li></ul><p>在这个例子中，”woman” 是先行词，而 “who” 引导的从句进一步描述了这个女人。关系从句 “who lives next door” 进一步说明了哪个女人是医生。</p><h4 id="代词"><a href="#代词" class="headerlink" title="代词"></a>代词</h4><p>代词是一类用来替代名词或名词短语的单词。它们可以节省语言，减少句子中重复的单词，使句子更加简洁明了。代词可以在句子中充当主语、宾语、定语或表语等不同的语法角色。</p><p>常见的代词包括：</p><ol><li>人称代词（personal pronouns），如“he”、“she”、“they”等，用于代指人；</li><li>物主代词（possessive pronouns），如“mine”、“yours”、“theirs”等，用于表示所有权；</li><li>反身代词（reflexive pronouns），如“myself”、“yourself”、“himself”等，用于强调动作的执行者是主语本身；</li><li>相互代词（reciprocal pronouns），如“each other”、“one another”，用于描述两个或多个人之间的相互关系。</li></ol><p>以下是代词在句子中的例子：</p><ul><li>“He went to the store.”（他去商店了。）这里，“he”是主语代词，代替具体的人名或人物。</li><li>“This is mine.”（这是我的。）这里，“mine”是物主代词，代替一个特定的所有者。</li><li>“They hurt themselves during the game.”（他们在比赛中伤了自己。）这里，“themselves”是反身代词，代表主语本身。</li><li>“The two friends hugged each other goodbye.”（两位朋友互相拥抱告别。）这里，“each other”是相互代词，表示两个人之间的相互关系。</li></ul><h5 id="关系代词"><a href="#关系代词" class="headerlink" title="关系代词"></a>关系代词</h5><p>关系代词（Relative pronoun）是一类用来引导限定性从句的代词。它们可以在从句中充当主语、宾语或表语等成分，并且与先行词有所关联，起到将从句和主句紧密联系在一起的作用。</p><p>常见的关系代词包括：who, whom, whose, which, that。例如，在句子“People who live in glass houses shouldn’t throw stones”，“who”是一个关系代词，引导了一个限定性从句（people who live in glass houses），并且在从句中充当主语。</p><p>需要注意的是，关系代词只能用来引导限定性从句，而不能用来引导非限定性从句（non-restrictive clause）。在使用关系代词时，需要注意先行词与从句之间的语法和意义关系，以确保句子的表达准确清晰。</p><h3 id="固定搭配"><a href="#固定搭配" class="headerlink" title="固定搭配"></a>固定搭配</h3><p>”not only…but also..     “不仅……而且……”</p><p>“as well as” 是一个连接词，表示“和”、“也”等意思，用于连接两个并列的短语。在该句中，它连接了两个并列的目的状语。</p>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/undefinedDocker-0/"/>
      <url>/undefinedDocker-0/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>容器共享一个操作系统，只隔离了运行环境。</p><p>容器运用了集装箱的概念，程序运行的环境（依赖）就是集装箱，里面装载了程序。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/v2-907214eadd65987e84a0751c08143f91.jpeg" alt="v2-907214eadd65987e84a0751c08143f91"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/v2-0f6ede7f0b920b5d0d5571c937a04838.jpeg" alt="v2-0f6ede7f0b920b5d0d5571c937a04838"></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>提供一个简单、轻量的建模方法</p><p>职责的逻辑分离：程序开发人员关心容器中运行的程序，运维人员关心容器管理，降低“开发时正常，是运维的问题”的风险。</p><p>快速高效的开发生命周期：docker目标缩短代码从开发到测试到部署到上线的周期，让应用程序具备可以移植性，易于构建，并易于协作。</p><p>鼓励使用面向服务的架构：docker推荐单个容器运行一个应用程序，这样就形成了一个分布式的应用程序模型。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>容器实际是一种沙盒技术，就是能够像一个集装箱一样把你的应用装起来的技术。应用之间有了边界，不至于互相干扰，也可以方便的搬来搬去，实现了pass的最理想状态。</p><p>提供的数据+程序&#x3D;可执行镜像（executable image）</p><p>cgroups技术用来制造约束，namespace技术是用来修改进程视图的主要方法。</p><h3 id="namespace（隔离）"><a href="#namespace（隔离）" class="headerlink" title="namespace（隔离）"></a>namespace（隔离）</h3><p>在宿主机上运行一个程序系统就会给她分配一个PID，但在docker中运行就会对隔离应用的进程空间动手脚</p><p>他只是linux创建新进程的一个可选的参数，Linux系统中创建线程的系统调用是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pid =clone(main_function, stack_size, SIGCHLD, NULL);</span><br><span class="line">#在参数中指定创建新的进程</span><br><span class="line">int pid =clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</span><br><span class="line">#指定参数后，此时新创建的这个进程将会看到一个全新的进程空间，再这个进程空间里，他的PID是1，但宿主机看到的还是100，多次执行clone（）就会创建多个PID Namespace，在这个namespce里的敬长都会仍未自己是当前容器里的一号进程，他看不到宿主机的进程空间。</span><br></pre></td></tr></table></figure><p>除了PID Namespacelinux还有Mount\UTS\IPC\Network和USER这些namespace</p><p>Mount namesspace用于让被隔离进程只看得到当前namespace里的挂载点信息，networknamespace让被隔离进程只看得到当前namespoace里的网络设置。</p><p>可见容器只是一组特殊的进程，内核时共享的，即容器不能运行windows，windwos的容器不能运行linux。</p><p>在linux内核中有很多资源兑现格式不能被namespace化的，比如系统时间，如果容器中调用settimeofday（2）系统调用修改了时间，因为内核共享会导致整个宿主机的时间被修改，因为共享内核也会导致应用暴露攻击面变大。</p><p>容器虽然被namespace隔离但是他和其他进程时平等的，所以会共享cpu内存等，会被抢占也会被独占，这显然不符合沙盒，所以使用下面的</p><h3 id="Cgroups（限制）"><a href="#Cgroups（限制）" class="headerlink" title="Cgroups（限制）"></a>Cgroups（限制）</h3><p>Linux Cgroups(linux control groups)是linux内核中用来<strong>为进程设置资源限制</strong>的一个重要功能。</p><p>防止单个容器耗广物理机性能</p><p>Cgroups&#x3D;子系统目录+资源限制文件</p><p>linux cgroups最主要的功能是限制一个进程组能够使用的资源上限，包括cpu、内存、磁盘、网络带宽等等。</p><p>cgroup还能能够对进程进行优先级设置、审计、以及将进程挂起和恢复等操作。</p><p>在linux中，cgroups向用户暴露出来的操作接口是文件系统，他以文件和目录的方式组织在操作系统的&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;。（可以用 mount -t cgroup查看）</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221120220329894.png" alt="image-20221120220329894"></p><p>在cgroup目录下面有很多文件，下面的这些子目录叫做<strong>子系统</strong>，这些都是这台及其可以被cgroup显示的资源种类。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221116232708676.png" alt="image-20221116232708676"></p><p>cgroup的每一项子系统都有其独特的资源限制能力</p><p>blkio,为块设备设定I&#x2F;O限制，一般用于磁盘等设备</p><p>cpuset,为进程分配单独的cpu核和对应的内存结点</p><p>memory，为进程设定内存使用限制</p><p>docker在每个子系统下面为每个容器创建一个控制组（目录），在容器启动后把这个进程pid写道对应控制组的tasks文件中即可</p><p>写的数由用户决定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpu-period=100000 --cpu-guota=20000 ubuntu /bin/bash</span><br><span class="line">cpu带宽等于quota+period,此处cpu带宽等于100000us(100ms)+20000(20ms)=在每100ms时间里，该控制组限制的进程只能使用20ms的cpu时间，即该进程只能是用到20%的带宽</span><br></pre></td></tr></table></figure><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221120222938705.png" alt="image-20221120222938705"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221120222946788.png" alt="image-20221120222946788"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221120222959287.png" alt="image-20221120222959287"></p><p>cgroup对资源限制有很多不足的地方，比如&#x2F;proc文件系统，在容器里面运行top你会发现他显示的是宿主机的，因为&#x2F;proc文件系统不知道用户通过cgroups给这个容器进行了限制，即&#x2F;proc不了解cgroups限制的存在。</p><h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>容器镜像，根文件系统</p><p>创建新进程时候，mount namespace修改的是容器进程对文件系统挂载点的认知，这也意味着只有在挂载这个操作发生之后（即重新挂载），进程的视图才会改变，否则新创建的容器和其他进程一样直接继承宿主机的各个挂载点。</p><p>mount namespace跟其他的namespace略有不同就是：他对容器进程视图的改变一定要伴随着挂在操作才能生效。</p><p>可是我们希望没创建一个新的容器时，容器进程看到的文件系统就是一个独立的环境，而不是继承，那么我们可以在容器进程启动之前重新挂载他的整个根目录&#x2F;，而由于mount namespace的存在这个挂载对于宿主不可见，容器可以随便倒腾。</p><p>chroot可以改变进程的根目录，mount namespace就是基于chroot改良过来。</p><p>change root file system 改变进程根目录到指定位置</p><p>为了让容器的根目录看起来更真实一般会在这个容器的根目录下挂载一套完整的操作系统的文件系统。</p><p>这个挂载在容器根目录上用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。他的另一个名字就叫rootfs（根文件系统），它不包含内核，rootfs只是一个操作系统所包含的文件、配置和目录。</p><p>一个常见的rootfs包括以下目录</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221121010708835.png" alt="image-20221121010708835"></p><p>rootfs给了容器：一致性</p><p>rootfs里打包的不只是应用，而是整个操作系统文件和目录，意味着应用以及它运行所需要的所有依赖都封装在了一起，所以容器有了最好的迁移性。</p><h3 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h3><p>在工作中，修改都是基于旧的rootfs，比如同事用ubuntu制作了一个rootfs并安装了java环境，用来部署我的java应用，那么我的朋友在发布他的java应用时想使用我安装过java环境的rootfs。那么我们可以增量修改，只需要去维护相对于base rootfs的增量内容，而不必每次都去制造一个fork。</p><p>因此引入了层的概念（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量rootfs，这种技术使用了UnionFS（union file system,联合文件系统）。他将不同位置的目录联合挂在（union mount）道同一个目录下。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/IMG_20221121_011948_edit_6575732350036.jpg" alt="IMG_20221121_011948_edit_6575732350036"></p><p>此时在c里对abx修改，A，和B中也会生效</p><h4 id="AuFS"><a href="#AuFS" class="headerlink" title="AuFS"></a>AuFS</h4><p>在docker中使用的unionFS式AuFS（Another UnionFS,后更名为Alternative UnionFS，再后来叫Advance UnionFS），所以他是原生linuxUnionFS的重写和改进</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/image-20221121013303379.png" alt="image-20221121013303379"></p><p>这个就有11层组成，即五个增量rootfs，run时docker会把增量联合起来统一挂载在一个点</p><img src="C:\Users\Mgrsc\Desktop\study\it\Cloudcompute\Container\docker\assets\文档扫描_20221121_014036350.jpg" alt="文档扫描_20221121_014036350" style="zoom: 25%;" /><p>1.只读层</p><p>只读层联合挂载的方式是只读（ro+wh，readonly+whiteout）</p><p>2.可读写层</p><p>挂载方式是rw，再写入文件前该目录是空的，一旦在容器里面进行了写操作，我的修改i内容就会以增量的方式写入该层。</p><p>如果我们要删除一个只读层的文件AuFS就会在可读写层创建一个witeout（白障）文件，把只读层里面的文件“遮挡”起来。</p><p><strong>所以该层是专门用来存放我修改rootfs后产生的增量的，无论增删减改</strong>，修改完后可以用docker commit和push保存这个可读写层</p><p>3.Init层</p><p>该层是一个以-init结尾的层，是docker项目单独生成的一个内部层，专门存放&#x2F;etc&#x2F;hosts   &#x2F;etc&#x2F;resolv.conf等信息</p><p>这些文本本来属于只读ubuntu的一部分但是用户往往会给一些指定值（比如hostname），所以需要在可读写层修改他们，可是我们在commit时候不希望把这些消息也连同提交，所以docker把该层独立出来，在用户执行docker commit时候只会提交可读写层。</p><p>docker commit 激素hi在容器运行起来之后把最上层的可读写层加上原先的容器镜像的只读层，打包成一个镜像，下面这些只读层在宿主机上是共享的不会占用额外的空间。</p><p>由于使用了unionfs，因此在容器里对镜像rootfs所做的任何修改都会被操作系统先复制到这个可读写曾然后在修改，这就是copy-on-write写时复制</p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p>所以docker项目最核心的原理就是：</p><ol><li>启用Linux Namespace配置；</li><li>设置指定的Cgroups参数;</li><li>切换进程的根目录（change root).</li></ol><p>一個正在運行的linux容器可以由：</p><ol><li>一組聯合挂在在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt上的rootfs，這一部分稱爲容器鏡像（container images),是容器的靜態視圖；</li><li>一個由namespace+cgroup構成的隔離環境，這一部分稱爲容器運行時(container runtime),是容器的動態視圖。</li></ol><h2 id="docker的组件"><a href="#docker的组件" class="headerlink" title="docker的组件"></a>docker的组件</h2><h5 id="Docker的核心组件："><a href="#Docker的核心组件：" class="headerlink" title="Docker的核心组件："></a>Docker的核心组件：</h5><p>1.Docker客户端和服务器，也成为docker引擎：docker是一个客户端、服务器（C&#x2F;S）架构的程序</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/IMG_20221014_003816_edit_459993809165747.jpg" alt="IMG_20221014_003816_edit_459993809165747"></p><p>2.docker镜像（image)：用户基于镜像来运行自己的容器。镜像也是docker生命周期中“构建”的部分。镜像是基于联合（Union）文件系统的一种层式结构，由一系列指令一步一步构建出来。</p><p>3.docker容器：用户只需要把自己的应用程序或者服务打包放进容器即可，容器基于镜像启动，容器可以运行一个或多个进程。镜像是docker生命周期中的构建或打包阶段，容器则是启动或执行阶段。docker容器就是一个镜像格式；一系列标准操作；一个执行环境。</p><p>4.Registry：Docker用Registry来保护用户构建的镜像。Registry分为公共和私有，docker公司运营的公共Registry叫做Docker Hub。</p><p>Docker借鉴了集装箱概念，每个容器都包含一个软件镜像，也就是容器的货物，在这些操作中容器不关心塞了什么也不关心运到何方，和集装箱一样方便替换，可以叠加，易于分发，尽量通用。</p><h5 id="Docker的技术组件："><a href="#Docker的技术组件：" class="headerlink" title="Docker的技术组件："></a>Docker的技术组件：</h5><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/IMG_20221014_005101.jpg" alt="IMG_20221014_005101"></p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/IMG_20221014_005342.jpg" alt="IMG_20221014_005342"></p><h5 id="docker工作流程"><a href="#docker工作流程" class="headerlink" title="docker工作流程"></a>docker工作流程</h5><p>1.docker build</p><p>当我们写完dockerfile交给docker“编译”时使用这个命令，那么client在接收到请求后转发给docker daemon，接着docker daemon根据dockerfile创建出“可执行程序”image。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/v2-f16577a98471b4c4b5b1af1036882caa.jpeg" alt="v2-f16577a98471b4c4b5b1af1036882caa"></p><p>2.docker run</p><p>有了“可执行程序”image后就可以运行程序了，接下来使用命令docker run，docker daemon接收到该命令后找到具体的image，然后加载到内存开始执行，image执行起来就是所谓的container。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/v2-672b29e2d53d2ab044269b026c6bc473.jpeg" alt="v2-672b29e2d53d2ab044269b026c6bc473"></p><p>3.docker pull</p><p>那么docker pull是什么意思呢？</p><p>我们之前说过，docker中image的概念就类似于“可执行程序”，我们可以从哪里下载到别人写好的应用程序呢？很简单，那就是APP Store，即应用商店。与之类似，既然image也是一种“可执行程序”，那么有没有”Docker Image Store”呢？答案是肯定的，这就是Docker Hub，docker官方的“应用商店”，你可以在这里下载到别人编写好的image，这样你就不用自己编写dockerfile了。</p><p>docker registry 可以用来存放各种image，公共的可以供任何人下载image的仓库就是docker Hub。那么该怎么从Docker Hub中下载image呢，就是这里的docker pull命令了。</p><p>因此，这个命令的实现也很简单，那就是用户通过docker client发送命令，docker daemon接收到命令后向docker registry发送image下载请求，下载后存放在本地，这样我们就可以使用image了。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/v2-dac570abcf7e1776cc266a60c4b19e5e.jpeg" alt="v2-dac570abcf7e1776cc266a60c4b19e5e"></p><h5 id="docker的底层实现"><a href="#docker的底层实现" class="headerlink" title="docker的底层实现"></a>docker的底层实现</h5><p>docker基于Linux内核提供这样几项功能实现的：</p><p>NameSpace<br>我们知道Linux中的PID、IPC、网络等资源是全局的，而NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰，这就使得每个NameSpace看上去就像一个独立的操作系统一样，但是只有NameSpace是不够。<br>Control groups<br>虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。<br>有了这两项技术，容器看起来就真的像是独立的操作系统了。</p><h2 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h2><h3 id="Docker容器使用"><a href="#Docker容器使用" class="headerlink" title="Docker容器使用"></a>Docker容器使用</h3><h5 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h5><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。</p><ul><li><p><strong>docker:</strong> Docker 的二进制执行文件。</p></li><li><p><strong>run:</strong> 与前面的 docker 组合来运行一个容器。</p></li><li><p><strong>ubuntu:15.10</strong> 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</p></li><li><p><strong>&#x2F;bin&#x2F;echo “Hello world”:</strong> 在启动的容器里执行的命令</p></li><li><p>–name 命名</p></li><li><p>–restart 让dockers自动重启因某种错误导致的容器停止运行</p></li><li><p>–add-host可以添加hosts记录</p></li><li><p>–hostname可以设置主机名</p></li><li><p>-v 将宿主机的目录作为卷，挂载到容器里，卷式在一个或多个容器内被共享的目录，可以绕过分层的联合文件系统，为docker提供持久数据或者共享数据，对卷的修改会直接生效，镜像提交时候，卷不包括在内。在最后加上：后跟权限可以指定容器内的目录的读写</p></li><li><p>–cpu-period&#x3D;  –cpu-quota&#x3D; 这两个参数需要结合使用，限制进程长度为period&#x3D;的一段时间内被分配到总量为quota&#x3D;的cpu时间，该限制可以在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;容器id找到</p></li><li><p>–net&#x3D; 指定了容器在哪个网络中运行(–net&#x3D;host不使用network namespace即不创建网络，使用宿主机网络)，network namespace加入。</p></li><li><p>–env 指定容器的环境变量，在容器内使用代理需要设置env为<code>http_proxy=&quot;socks5://宿主机的地址:10808&quot;</code></p></li></ul><p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin&#x2F;echo “Hello world”，然后输出结果。</p><ul><li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li><li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul><p>注意第二行 **root@0123ce188bd8:&#x2F;#**，此时我们已进入一个 ubuntu15.10 系统的容器</p><p>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</p><p>-d 创建一个运行在后台的容器</p><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running 或 Up（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><h5 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h5><p>在宿主主机内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出</p><h5 id="docker-stop-amp-amp-docker-skill"><a href="#docker-stop-amp-amp-docker-skill" class="headerlink" title="docker stop &amp;&amp; docker skill"></a>docker stop &amp;&amp; docker skill</h5><p>docker stop 发送SIGTERM信号，缓慢停止</p><p>docker kill 发送SIGKILL信号，快速杀死容器</p><h5 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h5><p>获取容器&#x2F;镜像的元数据。</p><ul><li>**-f :**指定返回值的模板文件。</li><li>**-s :**显示总的文件大小。</li><li>**–type :**为指定类型返回JSON。</li><li>–format：支持go语言</li></ul><h5 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h5><p>查看容器</p><ul><li>**-a :**显示所有的容器，包括未运行的。</li><li>**-f :**根据条件过滤显示的内容。</li><li>**–format :**指定返回值的模板文件。</li><li>**-l :**显示最近创建的容器。</li><li>**-n :**列出最近创建的n个容器。</li><li>**–no-trunc :**不截断输出。</li><li>**-q :**静默模式，只显示容器编号。</li><li>**-s :**显示总的文件大小。</li></ul><h5 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h5><p>附着到容器上。</p><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保CTRL-D或CTRL-C不会关闭容器。</p><ul><li>可以使用 <code>docker exec -it 容器id /bin/bash</code> 进入容器并开启一个新的bash终端。 <strong>退出容器终端时，不会导致容器的停止。</strong></li><li>使用 <code>docker attach 容器id</code> 进入正在执行容器，不会启动新的终端， <strong>退出容器时，会导致容器的停止。</strong></li></ul><h5 id="docker-logs-1"><a href="#docker-logs-1" class="headerlink" title="docker logs"></a>docker logs</h5><p>获取容器日志</p><ul><li><strong>-f :</strong> 跟踪日志输出</li><li>**–since :**显示某个开始时间的所有日志</li><li><strong>-t :</strong> 显示时间戳</li><li>**–tail :**仅列出最新N条容器日志</li></ul><h5 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h5><p>查看容器中运行的进程信息，支持 ps 命令参数。</p><h5 id="docker-stats"><a href="#docker-stats" class="headerlink" title="docker stats"></a>docker stats</h5><p>显示容器资源的使用情况，包括：CPU、内存、网络 I&#x2F;O 等。</p><ul><li>**–all , -a :**显示所有的容器，包括未运行的。</li><li>**–format :**指定返回值的模板文件。</li><li>**–no-stream :**展示当前状态就直接退出了，不再实时更新。</li><li>**–no-trunc :**不截断输出。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$  docker stats</span><br><span class="line">CONTAINER ID        NAME                                    CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">b95a83497c91        awesome_brattain                        0.28%               5.629MiB / 1.952GiB   0.28%               916B / 0B           147kB / 0B          9</span><br><span class="line">67b2525d8ad1        foobar                                  0.00%               1.727MiB / 1.952GiB   0.09%               2.48kB / 0B         4.11MB / 0B         2</span><br><span class="line">e5c383697914        test-1951.1.kay7x1lh1twk9c0oig50sd5tr   0.00%               196KiB / 1.952GiB     0.01%               71.2kB / 0B         770kB / 0B          1</span><br><span class="line">4bda148efbc0        random.1.vnc8on831idyr42slu578u3cr      0.00%               1.672MiB / 1.952GiB   0.08%               110kB / 0B          578kB / 0B          2</span><br></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID 与 NAME:</strong> 容器 ID 与名称。</p><p><strong>CPU % 与 MEM %:</strong> 容器使用的 CPU 和内存的百分比。</p><p><strong>MEM USAGE &#x2F; LIMIT:</strong> 容器正在使用的总内存，以及允许使用的内存总量。</p><p><strong>NET I&#x2F;O:</strong> 容器通过其网络接口发送和接收的数据量。</p><p><strong>BLOCK I&#x2F;O:</strong> 容器从主机上的块设备读取和写入的数据量。</p><p><strong>PIDs:</strong> 容器创建的进程或线程数。</p><h5 id="docker-start-x2F-stop-x2F-restart"><a href="#docker-start-x2F-stop-x2F-restart" class="headerlink" title="docker start&#x2F;stop&#x2F;restart"></a>docker start&#x2F;stop&#x2F;restart</h5><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><h5 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h5><p>在运行的容器中执行命令</p><ul><li>**-d :**分离模式: 在后台运行</li><li>**-i :**即使没有附加也保持STDIN 打开</li><li>**-t :**分配一个伪终端</li></ul><p>一个进程的每种linux namespace都在他对应的&#x2F;proc&#x2F;进程号&#x2F;ns下雨哦一个对应的虚拟文件，并且连接到一个真实的namespace文件上，这样加入进程的某个已有namespce中即可进入</p><p>系统通过open（）系统调用打开指定的namespace文件，并且把该文件的描述符fd交给setns（）使用，在setns（）执行后，当前进程就加入了这个文件对应的了inuxnamespace中了。</p><p>可以使用 <code>docker exec -it 容器id /bin/bash</code> 进入容器并开启一个新的bash终端。 <strong>退出容器终端时，不会导致容器的停止。</strong></p><p>使用 <code>docker attach 容器id</code> 进入正在执行容器，不会启动新的终端， <strong>退出容器时，会导致容器的停止。</strong></p><h5 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h5><ul><li>**-f :**通过 SIGKILL 信号强制删除一个运行中的容器。</li><li>**-l :**移除容器间的网络连接，而非容器本身。</li><li>**-v :**删除与容器关联的卷。</li></ul><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><h5 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h5><ul><li><p>**-a :**列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p></li><li><p>**–digests :**显示镜像的摘要信息；</p></li><li><p>**-f :**显示满足条件的镜像；</p></li><li><p>**–format :**指定返回值的模板文件；</p></li><li><p>**–no-trunc :**显示完整的镜像信息；</p></li><li><p>**-q :**只显示镜像ID。</p></li></ul><h5 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h5><ul><li><p>**-a :**拉取所有 tagged 镜像</p></li><li><p>**–disable-content-trust :**忽略镜像的校验,默认开启</p></li></ul><h5 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h5><p>从Docker Hub查找镜像</p><ul><li>**–automated :**只列出 automated build类型的镜像；</li><li>**–no-trunc :**显示完整的镜像描述；</li><li>**-f &lt;过滤条件&gt;:**列出收藏数不小于指定值的镜像。</li></ul><h5 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h5><p>从容器创建一个新的镜像。</p><ul><li><p>**-a :**提交的镜像作者；</p></li><li><p>**-c :**使用Dockerfile指令来创建镜像；</p></li><li><p>**-m :**提交时的说明文字；</p></li><li><p>**-p :**在commit时，将容器暂停。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><h5 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h5><p>删除本地一个或多个镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f :强制删除；</span><br><span class="line"></span><br><span class="line">--no-prune :不移除该镜像的过程镜像，默认移除；</span><br></pre></td></tr></table></figure><h4 id="dockerfire"><a href="#dockerfire" class="headerlink" title="dockerfire"></a>dockerfire</h4><p>在dockerfile中每个原语执行后，都会生成一个对应的镜像层</p><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><strong>FROM</strong></h5><p>定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><strong>RUN</strong></h5><p>指定镜像被构建时要运行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shell 格式：</span><br><span class="line"></span><br><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br><span class="line">exec 格式：</span><br><span class="line"></span><br><span class="line">以下通过数组传递是为了避免命令自动加入/binsh -c带来的错误**</span><br><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"># 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>容器被启动时要运行的，推荐使用数组方式设置：CMD[“&#x2F;bin&#x2F;true”]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD 在docker run 时运行。</span><br><span class="line">RUN 是在 docker build。</span><br><span class="line">如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</span><br></pre></td></tr></table></figure><p>docker run 可以覆盖CMD指令</p><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p><strong>运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</span><br><span class="line"></span><br><span class="line">#注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生#效。</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">  &amp;&amp; **wget** -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>可以通过-w标制在运行时覆盖工作目录</p><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>设置环境变量，定义了环境变量，那么在后续的RUN指令中，就可以使用这个环境变量（如同在命令前指定了前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm</span><br><span class="line">RUN gem install unicorn == RVM_PATH=/home/rvm/ gem install unicorn</span><br></pre></td></tr></table></figure><p>也可使用docker run命令-e标制来传递环境变量。但只在运行时有效。</p><h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>docker run -u 可以覆盖</p><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>基于镜像创建的容器添加卷，一个卷时可以存在于一个或者多个容器内的特定目录，这个目录可以绕过联合文件系统。可以让我们将数据、数据库、或者其他内容添加到镜像中而不是将他们提交到镜像中，并且允许我们在多个容器见共享这些内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/opt/project&quot;]#会基于镜像创建的任何容器创建一个名为/opt/project 的挂载点</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li><li>卷可以在容器间共享和重用</li><li>对卷的修改时立即生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在直到没有任何容器使用它</li></ul><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。将宿主机的目录作为卷，挂载到容器里。</p><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY），将构建目录下的文件复制到镜像中的指定位置，指向源文件的位置参数可以是一个url，或者构建上下文或者环境中文件名或者目录，也可以时压缩文件，压缩文件会自动解压。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>同ADD类似但是不会去做文件提取和解压。</p><h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><p>指令为Docker镜像添加元数据。元数据以键值对的形式展开。可以通过docker inspect查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><h5 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h5><p>用来设置停止容器时发送什么系统调用信号给容器。这个信号必须时内核系统调用表中合法的数，如9或者SIGNAME格式中的信号名称，如SIGKILL</p><h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</p><h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><h5 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h5><p>于使用 Dockerfile 创建镜像。</p><ul><li>**–build-arg&#x3D;[] :**设置镜像创建时的变量；</li><li>**–cpu-shares :**设置 cpu 使用权重；</li><li>**–cpu-period :**限制 CPU CFS周期；</li><li>**–cpu-quota :**限制 CPU CFS配额；</li><li>**–cpuset-cpus :**指定使用的CPU id；</li><li>**–cpuset-mems :**指定使用的内存 id；</li><li>**–disable-content-trust :**忽略校验，默认开启；</li><li>**-f :**指定要使用的Dockerfile路径；</li><li>**–force-rm :**设置镜像过程中删除中间容器；</li><li>**–isolation :**使用容器隔离技术；</li><li>**–label&#x3D;[] :**设置镜像使用的元数据；</li><li>**-m :**设置内存最大值；</li><li>**–memory-swap :**设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>**–no-cache :**创建镜像的过程不使用缓存；</li><li>**–pull :**尝试去更新镜像的新版本；</li><li>**–quiet, -q :**安静模式，成功后只输出镜像 ID；</li><li>**–rm :**设置镜像成功后删除中间容器；</li><li>**–shm-size :**设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li><li>**–ulimit :**Ulimit配置。</li><li>**–squash :**将 Dockerfile 中所有的操作压缩为一层。</li><li><strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>–network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p>最后一个点是上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p><p><strong>解析</strong>：由于 docker 的运行模式是 C&#x2F;S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p><p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p><h5 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h5><p>查看指定镜像的创建历史。</p><ul><li><p>**-H :**以可读的格式打印镜像大小和日期，默认为true；</p></li><li><p>**–no-trunc :**显示完整的提交记录；</p></li><li><p>**-q :**仅列出提交记录ID。</p></li></ul><h5 id="dockers-port"><a href="#dockers-port" class="headerlink" title="dockers port"></a>dockers port</h5><p>列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><p>-p映射到特定端口</p><h5 id="docker-pull-1"><a href="#docker-pull-1" class="headerlink" title="docker pull"></a>docker pull</h5><p>从镜像仓库中拉取或者更新指定镜像</p><ul><li><p>**-a :**拉取所有 tagged 镜像</p></li><li><p>**–disable-content-trust :**忽略镜像的校验,默认开启</p></li></ul><h5 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h5><p>将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><ul><li>**–disable-content-trust :**忽略镜像的校验,默认开启</li></ul><p>push到自己仓库时tag的username需要是自己</p><p><strong>perforin</strong>&#x2F;test:12121</p><h5 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h5><p>标记本地镜像，将其归入某一仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。</span><br><span class="line"></span><br><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure><h3 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h3><h4 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h4><p><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -P training/webapp python app.py</span><br><span class="line">fce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES</span><br><span class="line">fce072cc88ce    training/webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000/tcp   grave_hopper</span><br></pre></td></tr></table></figure><p><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES</span><br><span class="line">33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:5000-&gt;5000/tcp    berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:32768-&gt;5000/tcp   grave_hopper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES</span><br><span class="line">95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...  0.0.0.0:5000-&gt;5000/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     &quot;python app.py&quot;   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</span><br></pre></td></tr></table></figure><p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <strong>&#x2F;udp</strong>。</p><p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。</p><h4 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h4><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p><p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p><h5 id="docekr-–link"><a href="#docekr-–link" class="headerlink" title="docekr –link"></a>docekr –link</h5><p>可以一次性指定多个</p><p>docker在父容器的这些地方写了连接信息</p><ul><li>&#x2F;etc&#x2F;hosts</li><li>包含连接信息的环境变量中（可以在容器内用env查看）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1234 \</span><br><span class="line">--name app \</span><br><span class="line">--link test1:ab \  #连接test1容器并为该服务增加ab别名</span><br><span class="line">-it \</span><br><span class="line">-v $PWD/app:/opt/app \</span><br><span class="line">ubuntu \</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>把容器连接在一起可以让客户容器直接访问任一服务容器的公开端口，更重要的是只有–link标制连接到这个容器的容器才可以连接到这个端口，容器的端口不需要对本地宿主机公开。</p><p>启动docker守护进程时候加上–icc&#x3D;false标制，可以关闭所有没有连接的容器间的通讯。</p><h4 id="docker-network"><a href="#docker-network" class="headerlink" title="docker network"></a>docker network</h4><p>docker0是一个虚拟的以太网桥，用于连接容器合本地宿主机网络，docker每创建一组互联的网络接口，这组接口就像管道的两端，这组接口其中一端作为容器eth0接口，而另一端统一命名为类似vethec6a这种名字，通过把每个veth*接口绑定到docker0网桥，docker就创建了一个虚拟子网，这个子网由宿主机合所有的docker容器共享。</p><h5 id="docker-network-create"><a href="#docker-network-create" class="headerlink" title="docker  network create"></a>docker  network create</h5><p>-d：参数指定 Docker 网络类型，有 bridge、overlay。</p><p>其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge test-net</span><br></pre></td></tr></table></figure><h5 id="docker-connect-网络-容器"><a href="#docker-connect-网络-容器" class="headerlink" title="docker connect  网络 容器"></a>docker connect  网络 容器</h5><p>将容器添加到已有的网络</p><h5 id="docker-disconnect-网络-容器"><a href="#docker-disconnect-网络-容器" class="headerlink" title="docker disconnect 网络 容器"></a>docker disconnect 网络 容器</h5><p>将容器移除网络</p><p><strong>全局dns</strong></p><p>我们可以在宿主机的 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动指定容器的配置</strong></p><p>如果只想在指定的容器设置 DNS，则可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><strong>–rm</strong>：容器退出时自动清理容器内部的文件系统。</p><p><strong>-h HOSTNAME 或者 –hostname&#x3D;HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 &#x2F;etc&#x2F;hostname 和 &#x2F;etc&#x2F;hosts。</p><p><strong>–dns&#x3D;IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 &#x2F;etc&#x2F;resolv.conf 中，让容器用这个服务器来解析所有不在 &#x2F;etc&#x2F;hosts 中的主机名。</p><p><strong>–dns-search&#x3D;DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p><h3 id="Docker-编排"><a href="#Docker-编排" class="headerlink" title="Docker 编排"></a>Docker 编排</h3><h4 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h4><p>用一个YAML文件定义一组要启动的容器，以及运行容器时的属性，dockercompose称这些容器为“服务”</p><p>容器通过某些方法并指定一些运行时的属性来和其他容器产生交互。</p><p>在测试目录中，执行以下命令来启动应用程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>如果你想在后台执行该服务可以加上 -d 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><strong>yml 配置指令参考</strong><br>version<br>指定本 yml 依从的 compose 哪个版本制定的。</p><p>build<br>指定为构建镜像上下文路径：</p><p>例如 webapp 服务，指定为从上下文路径 .&#x2F;dir&#x2F;Dockerfile 所构建的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure><p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - &quot;com.example.description=Accounting webapp&quot;</span><br><span class="line">        - &quot;com.example.department=Finance&quot;</span><br><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class="line">      target: prod</span><br></pre></td></tr></table></figure><p>context：上下文路径。<br>dockerfile：指定构建镜像的 Dockerfile 文件名。<br>args：添加构建参数，这是只能在构建过程中访问的环境变量。<br>labels：设置构建镜像的标签。<br>target：多层构建，可以指定构建哪一层。<br>cap_add，cap_drop<br>添加或删除容器拥有的宿主机的内核功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">ALL # 开启全部权限</span><br><span class="line">cap_drop:</span><br><span class="line">SYS_PTRACE # 关闭 ptrace权限</span><br><span class="line">cgroup_parent</span><br><span class="line">为容器指定父 cgroup 组，意味着将继承该组的资源限制。</span><br><span class="line">cgroup_parent: m-executor-abcd</span><br></pre></td></tr></table></figure><p>command<br>覆盖容器启动的默认命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure><p>container_name<br>指定自定义容器名称，而不是生成的默认名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure><p>depends_on<br>设置依赖关系。</p><ul><li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li><li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p><p>deploy<br>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      mode：replicated</span><br><span class="line">      replicas: 6</span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line">      labels: </span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;0.50&#x27;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#x27;0.25&#x27;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure><p>可以选参数：</p><p>endpoint_mode：访问集群服务的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint_mode: vip </span><br><span class="line">Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line">DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></pre></td></tr></table></figure><p>labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p><p>mode：指定服务提供的模式。</p><p>replicated：复制服务，复制指定服务到集群的机器上。</p><p>global：全局服务，服务将部署至集群的每个节点。</p><p>图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。</p><p>replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p><p>resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p><p>restart_policy：配置如何在退出容器时重新启动容器。</p><p>condition：可选 none，on-failure 或者 any（默认值：any）。<br>delay：设置多久之后重启（默认值：0）。<br>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。<br>window：设置容器重启超时时间（默认值：0）。<br>rollback_config：配置在更新失败的情况下应如何回滚服务。</p><p>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。<br>delay：每个容器组回滚之间等待的时间（默认为0s）。<br>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。<br>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。<br>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。<br>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。<br>update_config：配置应如何更新服务，对于配置滚动更新很有用。</p><p>parallelism：一次更新的容器数。<br>delay：在更新一组容器之间等待的时间。<br>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。<br>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。<br>max_failure_ratio：在更新过程中可以容忍的故障率。<br>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。<br>注：仅支持 V3.4 及更高版本。</p><p>devices<br>指定设备映射列表。</p><ul><li><pre><code>devices:  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;    dns<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  自定义 DNS 服务器，可以是单个值或列表的多个值。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  dns: 8.8.8.8</span><br><span class="line">  </span><br><span class="line">  dns:</span><br><span class="line">  </span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure>dns_search自定义 DNS 搜索域。可以是单个值或列表。</code></pre></li><li><p>&#96;&#96;&#96;<br>dns_search: example.com</p><p>dns_search:</p><ul><li>dc1.example.com</li><li>dc2.example.com<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entrypoint</span><br><span class="line">覆盖容器默认的 entrypoint。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>entrypoint: &#x2F;code&#x2F;entrypoint.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以是以下格式：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>entrypoint:<br>    - php<br>    - -d<br>    - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so<br>    - -d<br>    - memory_limit&#x3D;-1<br>    - vendor&#x2F;bin&#x2F;phpunit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">env_file</span><br><span class="line">从文件添加环境变量。可以是单个值或列表的多个值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>env_file: .env</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以是列表格式：</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    env_file:</span><br><span class="line">    </span><br><span class="line">      - ./common.env</span><br><span class="line">      - ./apps/web.env</span><br><span class="line">      - /opt/secrets.env</span><br></pre></td></tr></table></figure><pre><code>environment添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#x27;true&#x27;</span><br></pre></td></tr></table></figure><p>expose<br>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数：</p><ul><li><p>&#96;&#96;&#96;<br>expose:</p><ul><li>“3000”</li><li>“8000”<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  extra_hosts</span><br><span class="line">  添加主机名映射。类似 docker client --add-host。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  extra_hosts:</span><br><span class="line">  </span><br><span class="line">   - &quot;somehost:162.242.195.82&quot;</span><br><span class="line">   - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure></li></ul><p>以上会在此服务的内部容器中 &#x2F;etc&#x2F;hosts 创建一个具有 ip 地址和主机名的映射关系：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure><p>healthcheck<br>用于检测 docker 服务是否健康运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure><p>image<br>指定容器运行的镜像。以下格式都可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br><span class="line">logging</span><br></pre></td></tr></table></figure><p>服务的日志记录配置。</p><p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure><p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure><p>当达到文件限制上限，会自动删除旧得文件。</p><p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br><span class="line">network_mode</span><br></pre></td></tr></table></figure><p>设置网络模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br><span class="line">networks</span><br></pre></td></tr></table></figure><p>配置容器连接的网络，引用顶级 networks 下的条目 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure><p>aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</p><p>restart</p><ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure><p>注：swarm 集群模式，请改用 restart_policy。</p><p>secrets<br>存储敏感数据，例如密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br></pre></td></tr></table></figure><p>security_opt<br>修改容器默认的 schema 标签。</p><p>security-opt：</p><ul><li>label:user:USER   # 设置容器的用户标签</li><li>label:role:ROLE   # 设置容器的角色标签</li><li>label:type:TYPE   # 设置容器的安全策略标签</li><li>label:level:LEVEL  # 设置容器的安全等级标签<br>stop_grace_period<br>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒 </span><br></pre></td></tr></table></figure><p>默认的等待时间是 10 秒。</p><p>stop_signal<br>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p><p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p><p>stop_signal: SIGUSR1<br>sysctls<br>设置容器中的内核参数，可以使用数组或字典格式。</p><ul><li><p>&#96;&#96;&#96;<br>sysctls:<br>  net.core.somaxconn: 1024<br>  net.ipv4.tcp_syncookies: 0</p><p>sysctls:</p><ul><li>net.core.somaxconn&#x3D;1024</li><li>net.ipv4.tcp_syncookies&#x3D;0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  tmpfs</span><br><span class="line">  在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tmpfs: /run</span><br><span class="line">  </span><br><span class="line">  tmpfs:</span><br><span class="line">  </span><br><span class="line">    - /run</span><br><span class="line">    - /tmp</span><br></pre></td></tr></table></figure></li></ul><p>ulimits<br>覆盖容器默认的 ulimit。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure><p>volumes<br>将主机的数据卷或着文件挂载到容器里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class="line">            - &quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></pre></td></tr></table></figure><h3 id="Docker-集群管理（Swarm"><a href="#Docker-集群管理（Swarm" class="headerlink" title="Docker 集群管理（Swarm)"></a>Docker 集群管理（Swarm)</h3><p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p><p>支持的工具包括但不限于以下各项：</p><ul><li>Dokku</li><li>Docker Compose</li><li>Docker Machine</li><li>Jenkins</li></ul><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/services-diagram.png" alt="img"></p><h3 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h3><p>Docker一共提供了三种API</p><ul><li>Registry API:提供了和存储Docker镜像的Docker Registry集成的功能</li><li>Docker Hub API：提供了与Docker Hub集成的功能</li><li>Docker Remote API：提供了与Docker守护进程进行集成的功能</li></ul><h4 id="Docker-Remote-API"><a href="#Docker-Remote-API" class="headerlink" title="Docker Remote API"></a>Docker Remote API</h4><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。</p><p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p><p>YAML 的配置文件后缀为 <strong>.yml</strong>，如：<strong>runoob.yml</strong> 。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，<strong>只允许空格</strong></li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>YAML 支持以下几种数据类型：</p><ul><li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ul><h3 id="YAML-对象"><a href="#YAML-对象" class="headerlink" title="YAML 对象"></a>YAML 对象</h3><p>对象键值对使用冒号结构表示 <strong>key: value</strong>，冒号后面要加一个空格。</p><p>也可以使用 **key:{key1: value1, key2: value2, …}**。</p><p>还可以使用缩进表示层级关系；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key: </span><br><span class="line">    child-key: value</span><br><span class="line">    child-key2: value2</span><br></pre></td></tr></table></figure><p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?  </span><br><span class="line">    - complexkey1</span><br><span class="line">    - complexkey2</span><br><span class="line">:</span><br><span class="line">    - complexvalue1</span><br><span class="line">    - complexvalue2</span><br></pre></td></tr></table></figure><p>意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]</p><h3 id="YAML-数组"><a href="#YAML-数组" class="headerlink" title="YAML 数组"></a>YAML 数组</h3><p>以 <strong>-</strong> 开头的行表示构成一个数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">- C</span><br></pre></td></tr></table></figure><p>YAML 支持多维数组，可以使用行内表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key: [value1, value2, ...]</span><br></pre></td></tr></table></figure><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - A</span><br><span class="line"> - B</span><br><span class="line"> - C</span><br></pre></td></tr></table></figure><p>一个相对复杂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">companies:</span><br><span class="line">    -</span><br><span class="line">        id: 1</span><br><span class="line">        name: company1</span><br><span class="line">        price: 200W</span><br><span class="line">    -</span><br><span class="line">        id: 2</span><br><span class="line">        name: company2</span><br><span class="line">        price: 500W</span><br></pre></td></tr></table></figure><p>意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。</p><p>数组也可以使用流式(flow)的方式表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">companies: [&#123;id: 1,name: company1,price: 200W&#125;,&#123;id: 2,name: company2,price: 500W&#125;]</span><br></pre></td></tr></table></figure><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>数组和对象可以构成复合结构，例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line">  - Ruby</span><br><span class="line">  - Perl</span><br><span class="line">  - Python </span><br><span class="line">websites:</span><br><span class="line">  YAML: yaml.org </span><br><span class="line">  Ruby: ruby-lang.org </span><br><span class="line">  Python: python.org </span><br><span class="line">  Perl: use.perl.org</span><br></pre></td></tr></table></figure><p>转换为 json 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  languages: [ &#x27;Ruby&#x27;, &#x27;Perl&#x27;, &#x27;Python&#x27;],</span><br><span class="line">  websites: &#123;</span><br><span class="line">    YAML: &#x27;yaml.org&#x27;,</span><br><span class="line">    Ruby: &#x27;ruby-lang.org&#x27;,</span><br><span class="line">    Python: &#x27;python.org&#x27;,</span><br><span class="line">    Perl: &#x27;use.perl.org&#x27; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量是最基本的，不可再分的值，包括：</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><p>使用一个例子来快速了解纯量的基本使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  #true,True都可以</span><br><span class="line">    - FALSE  #false，False都可以</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    - 6.8523015e+5  #可以使用科学计数法</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    - 0b1010_0111_0100_1010_1110    #二进制表示</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#x27;node&#x27;</span><br><span class="line">    parent: ~  #使用~表示null</span><br><span class="line">string:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - &#x27;Hello world&#x27;  #可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - newline</span><br><span class="line">      newline2    #字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">date:</span><br><span class="line">    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">datetime: </span><br><span class="line">    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>&amp;</strong> 锚点和 ***** 别名，可以用来引用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure><p><strong>&amp;</strong> 用来建立锚点（defaults），**&lt;&lt;** 表示合并到当前数据，***** 用来引用锚点。</p><p>下面是另一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showell Steve </span><br><span class="line">- Clark </span><br><span class="line">- Brian </span><br><span class="line">- Oren </span><br><span class="line">- *showell </span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#x27;Steve&#x27;, &#x27;Clark&#x27;, &#x27;Brian&#x27;, &#x27;Oren&#x27;, &#x27;Steve&#x27; ]</span><br></pre></td></tr></table></figure><blockquote><p>参考地址：</p><ul><li><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">https://www.ruanyifeng.com/blog/2016/07/yaml.html</a></li><li><a href="https://www.jianshu.com/p/97222440cd08">https://www.jianshu.com/p/97222440cd08</a></li><li><a href="https://daihainidewo.github.io/blog/yaml%E6%95%99%E7%A8%8B/">https://daihainidewo.github.io/blog/yaml%E6%95%99%E7%A8%8B/</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Okkultismus</title>
      <link href="/undefinedOkkultismus/"/>
      <url>/undefinedOkkultismus/</url>
      
        <content type="html"><![CDATA[<h1 id="Okkultismus"><a href="#Okkultismus" class="headerlink" title="Okkultismus"></a>Okkultismus</h1><h2 id="介绍神秘学"><a href="#介绍神秘学" class="headerlink" title="介绍神秘学"></a>介绍神秘学</h2><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/A%20satire%20on%20the%20criticism%20of%20%20Witkiewicz,%201890,%20by%20Wojciech%20Piechowski.jpeg" alt="A satire on the criticism of  Witkiewicz, 1890, by Wojciech Piechowski"></p><h3 id="神秘学的定义和历史背景"><a href="#神秘学的定义和历史背景" class="headerlink" title="神秘学的定义和历史背景"></a>神秘学的定义和历史背景</h3><h4 id="神秘学的定义"><a href="#神秘学的定义" class="headerlink" title="神秘学的定义"></a>神秘学的定义</h4><p>神秘学（Mysticism）是指探索人类存在、灵性和神性等超自然领域的一种哲学领域。它是对人类生命及其存在本质的探究，是对智慧、真理和普遍价值观念的探寻，是一种超越物质世界、诉诸于直觉和个体经验的哲学思考方式。</p><p>神秘学涉及到各种不同的实践和信仰系统，包括但不限于占星学、塔罗牌、能量治疗、灵气、命理学和卜卦等。这些实践和信仰都有一个共同点，即认为人类和宇宙之间存在着某种联系，通过探究这种联系可以了解更深刻的真相和本质。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/Circe%20Offering%20the%20Cup%20to%20Ulysses%20by%20John%20William%20Waterhouse,%201891.jpeg" alt="Circe Offering the Cup to Ulysses by John William Waterhouse, 1891"></p><h4 id="神秘学的历史背景"><a href="#神秘学的历史背景" class="headerlink" title="神秘学的历史背景"></a>神秘学的历史背景</h4><p>神秘学的起源可以追溯到古代哲学和宗教的发展，例如古希腊的毕达哥拉斯学派、犹太教的克己复礼思想、基督教的修道运动和伊斯兰教的苏菲派等。在这些文化和思想传统中，神秘主义被视为一种寻求与神性或境遇直接交流的方式，无论是通过沉思、禁食、冥想、守夜或其他手段，神秘主义者都试图通过个人转化和经历来获得更深层次的觉悟和洞见。</p><p>在中世纪欧洲，神秘学成为了基督教精神生活的重要组成部分。许多圣人、修士、修女和神秘家通过禁欲、超验经验、幻觉和异象等方式，试图与上帝建立更亲密的关系。</p><p>随着现代科学和技术的进步，神秘学逐渐失去了在主流文化中的地位。但是，20世纪60年代以来，随着新时代思潮的兴起和反传统文化的流行，神秘学再次引起了人们的关注。当代人们越来越需要在日常生活中找到意义和方向，神秘学的理念和实践提供了一条通往内观和自我探索的道路。</p><p>总之，神秘学是一种哲学领域，旨在探索人类存在、灵性和神性等超自然领域，通过个体经验、洞察和直觉来解析人类生命及其存在本质，是一种正视人类文化、精神和宇宙本质的哲学思考方式。</p><h3 id="神秘学的流派和传统"><a href="#神秘学的流派和传统" class="headerlink" title="神秘学的流派和传统"></a>神秘学的流派和传统</h3><p>神秘学是一种寻求深层现实的理解和体验的追求。它涵盖了许多不同的学派和传统，包括西方神秘主义、印度教教义、佛教、伊斯兰教和犹太教等。以下是一些常见的神秘学派别和传统：</p><h4 id="西方神秘主义"><a href="#西方神秘主义" class="headerlink" title="西方神秘主义"></a>西方神秘主义</h4><p>西方神秘主义是指那些起源于欧洲的神秘学传统。这些传统通常与基督教有关，但也可能涉及其他宗教或哲学系统。西方神秘主义的一个关键概念是“内在之路”，即通过自我探索来获得心灵上的启示。其中一些著名的西方神秘主义者包括圣女德兰、约翰·坎特伯雷大主教和爱默生。</p><h4 id="犹太教的卡巴拉学派"><a href="#犹太教的卡巴拉学派" class="headerlink" title="犹太教的卡巴拉学派"></a>犹太教的卡巴拉学派</h4><p>卡巴拉学派是犹太教的一种神秘学传统。它的目标是揭示上帝的奥秘和创造世界的机制。卡巴拉学派强调通过祷告、冥想和研究犹太教经文来实现这一目标。其中最著名的卡巴拉学者是拉比·沙洛姆·道维·布斯托诺。</p><h4 id="佛教禅宗"><a href="#佛教禅宗" class="headerlink" title="佛教禅宗"></a>佛教禅宗</h4><p>禅宗是佛教中的一种神秘主义分支，其重点是通过冥想来认识真实的本性。禅宗修行者通常使用座禅、走路冥想和其他形式的冥想来实现这一目标。其中最著名的禅宗大师包括道元禅师和达摩祖师。</p><h4 id="伊斯兰教苏菲派"><a href="#伊斯兰教苏菲派" class="headerlink" title="伊斯兰教苏菲派"></a>伊斯兰教苏菲派</h4><p>苏菲派是伊斯兰教中的一种神秘主义传统。它的目标是通过研究古兰经和哈迪斯（先知穆罕默德的言行录）以及通过冥想和祷告来寻求真主的直接经验。苏菲派注重个人内心的成长和纯化，而不是传统的伊斯兰法律和规范。其中一些著名的苏菲派领袖包括鲁米、侯赛因·本·曼苏尔和穆伊丁·伊本·阿拉比。</p><h4 id="印度教教义"><a href="#印度教教义" class="headerlink" title="印度教教义"></a>印度教教义</h4><p>印度教教义包括许多不同的神秘学传统，最著名的是瑜伽学派。瑜伽学派的目标是通过冥想和身体训练来实现自我认识和超越。瑜伽学派也注重道德和伦理规范，如慈善、节制和非暴力。其他印度教神秘学传统包括教导灵性智慧的吠陀经和教导戒律和冥想的婆罗门教。</p><p>总的来说，神秘学派别和传统各具特色，但它们都强调通过自我探索和精神实践来获得更深层次的意义和智慧。这些实践方法通常包括冥想、占卜、能量治疗、灵气、灵性旅程和社群等，每个派别和传统都有其独特的方式和哲学观点。</p><p>此外，在现代社会中，神秘学也与心理学和自我探索等领域联系紧密。例如，许多心理治疗师和辅导员使用神秘学的原则和技术来帮助人们应对焦虑、抑郁和其他情绪问题。同时，神秘学也与新时代思潮、环保主义和人文主义等领域联系在一起，成为当代文化和精神生活的重要组成部分。</p><p>总之，神秘学涉及到许多不同的学派和传统，每个派别和传统都有其独特的哲学观点和实践方法。但它们都强调通过自我探索和精神实践来获得更深层次的意义和智慧，并与当代文化和精神生活联系紧密。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/Nightmare,%201800,%20by%20Nicolai%20Abraham%20Abildgaard.jpeg" alt="Nightmare, 1800, by Nicolai Abraham Abildgaard"></p><h3 id="神秘学的基本概念和术语"><a href="#神秘学的基本概念和术语" class="headerlink" title="神秘学的基本概念和术语"></a>神秘学的基本概念和术语</h3><p>神秘学是一种寻求深层现实的理解和体验的追求。它涉及到许多不同的学派和传统，并有其独特的哲学观点和实践方法。以下是一些常见的神秘学基本概念和术语：</p><h4 id="灵性"><a href="#灵性" class="headerlink" title="灵性"></a>灵性</h4><p>灵性是神秘学中最核心的概念之一。它通常被定义为超越物质世界的存在、真理和智慧。灵性强调个人内心的成长和纯化，以获得更高级别的意识和洞察力。与宗教信仰不同，灵性是一种广泛的、非宗教性的概念，可以适用于任何信仰体系或哲学系统。</p><h4 id="冥想"><a href="#冥想" class="headerlink" title="冥想"></a>冥想</h4><p>冥想是神秘学中最常见的实践方法之一。它通常涉及通过呼吸、静坐和专注来进入深层次的意识状态，以直接体验精神和灵性领域的真理和智慧。冥想可以帮助人们平衡身心、减轻压力、增加创造力和生产力等。</p><h4 id="占卜"><a href="#占卜" class="headerlink" title="占卜"></a>占卜</h4><p>占卜是一种探寻未知和预测未来的方法。它包括占星学、塔罗牌、命理学、卜卦和符号学等。这些实践方法试图通过某种形式的预测和解读，了解人类和宇宙之间的联系和本质。</p><h4 id="能量治疗"><a href="#能量治疗" class="headerlink" title="能量治疗"></a>能量治疗</h4><p>能量治疗是一种基于身体能量场的疗愈技术。它通过调节人体中的生命能量，以恢复身体和心灵的健康和平衡。能量治疗技术包括按摩、针灸、手印和能量传递等。</p><h4 id="灵气"><a href="#灵气" class="headerlink" title="灵气"></a>灵气</h4><p>灵气是一种源自日本的能量治疗技术，也称为“靈氣”、“気功”或“Reiki”。它通过将治疗者的手放在患者身上，向其传递能量来促进身体和心灵的疗愈。灵气也可以用于自我治疗和提高身体和心灵的能量水平。</p><h4 id="灵性旅程"><a href="#灵性旅程" class="headerlink" title="灵性旅程"></a>灵性旅程</h4><p>灵性旅程是一种通过灵性药物、冥想、音乐和其他手段，探寻灵性和神性的实践方法。通过这些实践，人们可以直接体验到超越物质世界的存在和真理。</p><h4 id="社群和仪式"><a href="#社群和仪式" class="headerlink" title="社群和仪式"></a>社群和仪式</h4><p>社群和仪式是神秘学中常见的实践方法之一。通过参与仪式、聚会或团体活动等方式，分享经验、探究真相，并建立更紧密的社交关系。社群和仪式也可以帮助人们感受到更大的归属感和包容性。</p><h4 id="大我"><a href="#大我" class="headerlink" title="大我"></a>大我</h4><p>大我是指超越个体自我的存在和意识。神秘主义者认为，通过消除个人自我和低级欲望的束缚，才能接近大我。大我也可以被看作是一个普遍的、全能的灵魂或神，可以通过冥想和灵性实践来探索和体验。</p><h4 id="启示和洞察力"><a href="#启示和洞察力" class="headerlink" title="启示和洞察力"></a>启示和洞察力</h4><p>启示和洞察力是神秘学中另外两个重要的概念。启示指的是通过直接经验、内心感应或灵性旅程等方式，获得深层次的意识和智慧。这种启示可以帮助人们理解对生命和宇宙的本质和实质的更深层次的理解。洞察力则是一种对信息的敏锐感知和理解，能够超越逻辑思考和常识判断，直接领悟真理和智慧。</p><h4 id="神秘主义"><a href="#神秘主义" class="headerlink" title="神秘主义"></a>神秘主义</h4><p>神秘主义是一种追求直接体验灵性和神性的哲学思想和实践方法。神秘主义者相信人类可以通过冥想、祷告、仪式和其他实践方式来获得超越日常现实的智慧和洞察。他们也认为，通过与大我和宇宙共鸣，在精神和身体方面实现平衡和和谐，就可以在人生中获得更高级别的意识和更深层次的体验。</p><p>总之，神秘学涉及到许多不同的基本概念和术语，每个概念和术语都有其独特的定义和含义。这些概念和术语强调了通过自我探索和精神实践来获得更深层次的意义和智慧，并帮助人们更好地了解宇宙和自己的本质。</p><h2 id="探索神秘学的实践方法"><a href="#探索神秘学的实践方法" class="headerlink" title="探索神秘学的实践方法"></a>探索神秘学的实践方法</h2><h3 id="冥想和呼吸法"><a href="#冥想和呼吸法" class="headerlink" title="冥想和呼吸法"></a>冥想和呼吸法</h3><p>冥想和呼吸法是神秘学中最常见和基本的实践方法之一。通过冥想和呼吸法，人们可以提高意识状态、平静思维、减轻压力、调整情绪等。以下是关于冥想和呼吸法的详细介绍：</p><h4 id="冥想-1"><a href="#冥想-1" class="headerlink" title="冥想"></a>冥想</h4><p>冥想是指通过专注内心来提高意识状态的实践方法。它可以帮助人们放松身体、集中精神，并探索自我和宇宙的本质。以下是一些常见的冥想技巧：</p><p>（1）正念冥想（Mindfulness Meditation）：正念冥想强调对当前经验的觉知和接受。在这种冥想中，人们会将注意力放在当前的感觉、思想和情绪上，并尝试不加评判地接受它们。</p><p>（2）瑜伽冥想（Yoga Meditation）：瑜伽冥想通常结合了冥想和体位练习。通过深入呼吸和体位练习，人们可以平衡身体和心灵的能量，提高意识状态。</p><p>（3）可视化冥想（Visualization Meditation）：可视化冥想通过想象力和意象来引导注意力和意识状态。在这种冥想中，人们会想象某些场景、形象或符号，以帮助他们进入更深层次的意识状态。</p><h4 id="呼吸法"><a href="#呼吸法" class="headerlink" title="呼吸法"></a>呼吸法</h4><p>呼吸法是指通过调节呼吸来平衡身体和心灵的能量的实践方法。它可以帮助人们放松身体、平衡情绪和思考，并提高意识状态。以下是一些常见的呼吸技巧：</p><p>（1）深度呼吸（Deep Breathing）：深度呼吸可以帮助人们缓解焦虑和压力，并促进身体的放松。在这种呼吸中，人们会长时间地吸气和呼气，以增加氧气的摄取和二氧化碳的排出。</p><p>（2）肚式呼吸（Diaphragmatic Breathing）：肚式呼吸可以帮助人们调节呼吸节奏和深度，并促进身体和心灵的平衡。在这种呼吸中，人们会通过肺部和腹部的运动来调节呼吸。</p><p>（3）阳性呼吸（Breath of Fire）：阳性呼吸是一种快速而有力的呼吸方法，可以帮助人们激发身体和心灵的能量。在这种呼吸中，人们会迅速地呼吸，每次吸气和呼气都要保持相同的长度，并通过鼻子进行。</p><p>通过冥想和呼吸法的实践，人们可以探索自我和宇宙的本质，提高意识状态，平衡身体和心灵的能量，以及释放压力和负面情绪。初学者可以透过参加班级和工作坊，阅读相关的书籍和文章，以及与其他神秘学爱好者交流和学习，了解和掌握冥想和呼吸法的技巧和实践方法。此外，以下是一些冥想和呼吸法的实践技巧：</p><ol><li>创建一个安静、舒适的环境。在进行冥想和呼吸法之前，选举一个安静的地方，并确保你感到舒适和放松。</li><li>集中注意力。在冥想和呼吸法中，集中注意力至关重要。你可以将注意力集中在呼吸、声音、感觉、形象或符号等任何东西上。</li><li>不加评判地接受经验。在冥想和呼吸法中，不加评判地接受自己的经验非常重要。无论出现什么样的感觉、思想和情绪，都尝试不做评价和反应。</li><li>练习定期冥想和呼吸法。通过定期的练习，你可以更好地掌握冥想和呼吸法的技巧和实践，从而获得更多的益处。</li><li>寻找指导和支持。如果你刚开始尝试冥想和呼吸法，寻找一个有经验的指导人员或者是参加一个小组，与其他冥想和呼吸法爱好者交流和学习。</li></ol><p>总之，冥想和呼吸法对于探索神秘学和提高意识状态非常有益。通过这些实践方法，人们可以平衡身体和心灵的能量，缓解压力和负面情绪，以及探索自我和宇宙的本质。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/The%20Roll%20of%20Fate%20by%20Walter%20Crane,%201882.jpeg" alt="The Roll of Fate by Walter Crane, 1882"></p><h3 id="卡巴拉和塔罗牌"><a href="#卡巴拉和塔罗牌" class="headerlink" title="卡巴拉和塔罗牌"></a>卡巴拉和塔罗牌</h3><p>卡巴拉和塔罗牌是西方神秘学中最常见和基本的传统之一。它们可以帮助人们深入探索自我和宇宙的本质，并获得更多的灵性洞察力。以下是关于卡巴拉和塔罗牌的详细介绍：</p><h4 id="卡巴拉"><a href="#卡巴拉" class="headerlink" title="卡巴拉"></a>卡巴拉</h4><p>卡巴拉是犹太教中的一种神秘学传统，意为“接受”或“传递”。它强调宇宙的结构和运作方式，并探索上帝的本质。卡巴拉的核心思想包括：</p><p>（1）世界由十个圆形和直线组成的图表所组成，这些图表被称为“副本”。</p><p>（2）每个“副本”都代表了不同的能量和层次，从物质世界到超越时间和空间的终极境界。</p><p>（3）每个“副本”都由四个不同的部分组成，分别代表物质、感知、情感和意志。</p><p>（4）通过学习卡巴拉，人们可以了解宇宙的本质，并掌握一些实践技巧，如奥秘的名字、语言符号等，以提高灵性洞察力。</p><h4 id="塔罗牌"><a href="#塔罗牌" class="headerlink" title="塔罗牌"></a>塔罗牌</h4><p>塔罗牌是一种用来预测未来和探索内在自我的工具。它由78张卡牌组成，分为大阿尔克那和小阿尔克那两类。以下是一些常见的塔罗牌卡片和其含义：</p><p>（1）愚者（The Fool）：这张牌代表新的开始、冒险和无畏的精神。</p><p>（2）女祭司（The High Priestess）：这张牌代表神秘、智慧和直觉。</p><p>（3）恋人（The Lovers）：这张牌代表真爱、合作和选择。</p><p>（4）死神（Death）：这张牌代表结束、转变和重生。</p><p>（5）太阳（The Sun）：这张牌代表幸福、成功和光明。</p><p>通过学习塔罗牌，人们可以深入探索自我和宇宙的本质，并获得更多的灵性洞察力。以下是一些常见的塔罗牌读牌技巧：</p><p>（1）三牌抽取法（Three-Card Spread）：这种读牌方法使用三张牌，分别代表过去、现在和未来。通过分析这些牌的含义，人们可以了解自己的状态和未来发展趋势。</p><p>（2）塔罗十字读牌法（Celtic Cross Spread）：这种读牌方法使用十张牌，每张牌代表不同的含义。通过分析这些牌的含义，人们可以深入探索自我和宇宙的本质。</p><p>总之，卡巴拉和塔罗牌是西方神秘学中最常见和基本的传统之一。通过学习卡巴拉和塔罗牌，人们可以深入探索自我和宇宙的本质，并获得更多的灵性洞察力。初学者可以透过阅读相关的书籍和文章，参加班级和工作坊，以及与其他神秘学爱好者交流和学习，了解和掌握卡巴拉和塔罗牌的技巧和实践方法。以下是一些关于学习卡巴拉和塔罗牌的技巧：</p><ol><li>阅读相关文献。了解卡巴拉和塔罗牌的历史、基本原理和使用方法，可以从书籍、文章和在线资源中获取。</li><li>参加班级和工作坊。参加班级和工作坊可以帮助人们深入了解卡巴拉和塔罗牌，以及掌握相应的实践技巧。</li><li>练习卡巴拉和塔罗牌。练习卡巴拉和塔罗牌可以提高灵性洞察力，并帮助人们更好地探索自我和宇宙的本质。</li><li>寻找指导和支持。如果你刚开始尝试卡巴拉和塔罗牌，寻找一个有经验的指导人员或参加小组，可以帮助你更好地了解卡巴拉和塔罗牌，并获得更多的实践技巧和建议。</li></ol><p>总之，卡巴拉和塔罗牌是西方神秘学中最常见和基本的传统之一。通过学习卡巴拉和塔罗牌，人们可以深入探索自我和宇宙的本质，并获得更多的灵性洞察力。初学者可以通过以上的学习和实践技巧来了解和掌握卡巴拉和塔罗牌的实践方法和技巧。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/John%20William%20Waterhouse,%20The%20Crystal%20Ball,%201902.jpeg" alt="John William Waterhouse, The Crystal Ball, 1902"></p><h3 id="能量治疗和灵气"><a href="#能量治疗和灵气" class="headerlink" title="能量治疗和灵气"></a>能量治疗和灵气</h3><p>能量治疗和灵气是指通过手法和意念来调节人体能量场，从而治疗身体、情感和精神问题的一种传统医疗方式。以下是关于能量治疗和灵气的详细介绍：</p><h4 id="能量治疗-1"><a href="#能量治疗-1" class="headerlink" title="能量治疗"></a>能量治疗</h4><p>能量治疗是一种基于能量理论的传统医疗方式，旨在通过手法和意念来调节人体能量场，从而治疗身体、情感和精神问题。能量治疗的核心思想包括：</p><p>（1）人体是由能量场组成的，包括生命能量、情绪能量和精神能量。</p><p>（2）能量场可以受到外界因素的影响，如压力、情绪和环境。</p><p>（3）通过调节能量场，可以促进身体自我修复和恢复平衡。</p><p>常见的能量治疗方式包括：</p><p>（1）按摩疗法：按摩疗法可以帮助释放肌肉紧张和疼痛，并促进血液循环和能量流动。</p><p>（2）针灸疗法：针灸疗法可以刺激穴位，改善身体内部的能量流动，从而缓解不适和疼痛。</p><p>（3）能量疗法：能量疗法包括磁疗、音疗、光疗等，可以帮助平衡能量场，促进自我修复和恢复平衡。</p><h4 id="灵气-1"><a href="#灵气-1" class="headerlink" title="灵气"></a>灵气</h4><p>灵气是一种基于日本传统医疗方式的能量治疗，旨在通过手法和意念来调节人体能量场，从而治疗身体、情感和精神问题。灵气的核心思想包括：</p><p>（1）人体是由能量场组成的，包括生命能量、情绪能量和精神能量。</p><p>（2）能量场可以受到外界因素的影响，如压力、情绪和环境。</p><p>（3）通过调节能量场，可以促进身体自我修复和恢复平衡。</p><p>灵气提倡“行者与患者共同作用”的原则，即行者通过手法和意念来调节患者的能量场，促进自我修复和恢复平衡。常见的灵气技术包括：</p><p>（1）手印：手印是指行者将手掌贴在患者身上特定的区域，以调整患者的能量场。</p><p>（2）呼吸调节法：呼吸调节法是指行者通过呼吸调节患者的能量场，从而促进自我修复和恢复平衡。</p><p>（3）意念调节法：意念调节法是指行者通过意念调节患者的能量场，从而促进自我修复和恢复平衡。</p><p>通过学习能量治疗和灵气，人们可以深入了解人体能量场的结构和运作方式，并学习一些实践技巧，如按摩、针灸和手印等，以提高自身的治疗能力和灵性洞察力。以下是一些关于学习能量治疗和灵气的技巧：</p><ol><li>学习相关的理论知识。了解能量治疗和灵气的历史、基本原理和使用方法，可以从书籍、文章和在线资源中获取。</li><li>参加培训课程和工作坊。参加培训课程和工作坊可以帮助人们深入了解能量治疗和灵气，以及掌握相应的实践技巧。</li><li>练习能量治疗和灵气。练习能量治疗和灵气可以提高灵性洞察力，并帮助人们更好地探索自我和宇宙的本质。</li><li>寻找指导和支持。如果你刚开始尝试能量治疗和灵气，寻找一个有经验的指导人员或参加小组，可以帮助你更好地了解能量治疗和灵气，并获得更多的实践技巧和建议。</li></ol><p>总之，能量治疗和灵气是一种传统医疗方式，旨在通过手法和意念来调节人体能量场，从而治疗身体、情感和精神问题。通过学习能量治疗和灵气，人们可以深入了解人体能量场的结构和运作方式，并学习一些实践技巧，如按摩、针灸和手印等，以提高自身的治疗能力和灵性洞察力。初学者可以透过阅读相关的书籍和文章，参加班级和工作坊，以及与其他医疗工作者和灵气爱好者交流和学习，了解和掌握能量治疗和灵气的技巧和实践方法。</p><h3 id="命理学和卜卦"><a href="#命理学和卜卦" class="headerlink" title="命理学和卜卦"></a>命理学和卜卦</h3><p>命理学和卜卦是指通过占卜、预测和解读命运的方式来探究人生和宇宙的一种传统学问。以下是关于命理学和卜卦的详细介绍：</p><h4 id="命理学"><a href="#命理学" class="headerlink" title="命理学"></a>命理学</h4><p>命理学是一种基于天文、历法、数学和哲学等知识的学问，旨在通过占卜、预测和解读命运的方式来探究人生和宇宙。命理学的核心思想包括：</p><p>（1）人生受到天时、地利、人和的影响。</p><p>（2）每个人出生时的时间和地点都对其命运有着决定性的影响。</p><p>（3）通过占卜、预测和解读命运，可以帮助人们更好地了解自我和宇宙的本质。</p><p>常见的命理学系统包括：</p><p>（1）八字命理学：八字命理学是中国传统的命理学系统，包括年柱、月柱、日柱和时柱四个柱子，以及十二个地支和十个天干组成的八个字。根据八字的组合和相互作用，可以预测一个人的命运、性格和健康状况等。</p><p>（2）西方占星学：西方占星学是一种基于星象和星座的命理学系统，旨在通过占卜、预测和解读星象来探究人生和宇宙。根据出生时太阳、月亮和行星所处的星座和宫位等，可以预测一个人的命运、性格和健康状况等。</p><h4 id="卜卦"><a href="#卜卦" class="headerlink" title="卜卦"></a>卜卦</h4><p>卜卦是一种古老的中国传统占卜系统，旨在通过投掷铜钱或蓍草，解析自然现象和人类行为，预测未来和指导人生。卜卦的核心思想包括：</p><p>（1）万物皆有灵气，自然现象和人类行为可以被解析和预测。</p><p>（2）卜卦可以帮助人们认识自己和周围的环境，指导人生。</p><p>常见的卜卦系统包括：</p><p>（1）周易卦：周易卦是中国传统卜卦系统中最为流行和广泛使用的一种，由六十四个卦象组成。通过投掷三枚硬币或六根蓍草，并按照特定的规则排列卦象，可以解析自然现象和人类行为，预测未来和指导人生。</p><p>（2）梅花易数：梅花易数是中国传统卜卦系统中的一种，以梅花图为工具，通过投掷两枚筛子和移动梅花图上的符号，来解析自然现象和人类行为，预测未来和指导人生。</p><p>通过学习命理学和卜卦，人们可以深入探究自我和宇宙的本质，预测和指导自己的命运和人生。以下是一些关于学习命理学和卜卦的技巧：</p><ol><li><p>学习相关的理论知识。了解命理学和卜卦的历史、基本原理和使用方法，可以从书籍、文章和在线资源中获取。</p></li><li><p>参加培训课程</p></li><li><p>和工作坊。参加命理学和卜卦的培训课程和工作坊可以帮助人们深入了解相关知识和技巧，并掌握相应的实践方法和技巧。</p><ol><li>练习命理学和卜卦。练习命理学和卜卦可以提高灵性洞察力，以及预测和指导人生的能力。</li><li>寻找指导和支持。如果你刚开始尝试命理学和卜卦，寻找一个有经验的指导人员或参加小组，可以帮助你更好地了解命理学和卜卦，并获得更多的实践技巧和建议。</li></ol><p>总之，命理学和卜卦是一种传统学问，旨在通过占卜、预测和解读命运的方式来探究人生和宇宙。通过学习命理学和卜卦，人们可以深入探究自我和宇宙的本质，预测和指导自己的命运和人生。初学者可以透过阅读相关的书籍和文章，参加班级和工作坊，以及与其他命理学和卜卦爱好者交流和学习，了解和掌握相关技巧和实践方法。</p></li></ol><h2 id="深入神秘学的主题"><a href="#深入神秘学的主题" class="headerlink" title="深入神秘学的主题"></a>深入神秘学的主题</h2><h3 id="意识与觉知"><a href="#意识与觉知" class="headerlink" title="意识与觉知"></a>意识与觉知</h3><p>意识和觉知是神秘学中最核心的主题之一。它们涉及到人类思维和感知的本质，以及个体与大我之间的关系。以下是对这些主题的更深入探讨：</p><ol><li>意识</li></ol><p>意识是指人们对自身和周围环境的认知和感知。在神秘学中，意识被视为一种超越物质世界的存在和能力，其背后是一种普遍的、全能的灵性或神性。某些神秘学传统认为，通过冥想和其他实践方式，人们可以超越常规意识状态，直接接触到更深刻的意识水平，以获得更高级别的洞察力和智慧。</p><ol><li>觉知</li></ol><p>觉知是指人们通过感知和意识来获取信息和经验的能力。它包括五个基本感官（视觉、听觉、嗅觉、味觉和触觉）以及内部感知，如情感、直觉和本能等。觉知也可以被看作是一种对现实的理解和感知的方式。在神秘学中，觉知被视为一种更高级别的智慧和指引，因为它可以帮助人们超越日常现实，探索更深层次的真相和本质。</p><ol><li>自我意识</li></ol><p>自我意识是指人们对自己的认知和感知。它涉及到个体对生命和存在的意义、目的和价值的理解和感知。在神秘学中，自我意识被视为一个重要的组成部分，因为它可以帮助人们实现更高级别的意识和意识水平。例如，通过消除个人自我和低级欲望的束缚，就可以接近大我或全能的灵魂或神。</p><ol><li>灵性觉醒</li></ol><p>灵性觉醒是指个体通过精神实践和探索，获得更高级别的意识和觉知的过程。这个过程通常包括通过冥想、仪式、瑜伽和灵性旅程等方式，探索神性和灵性领域，以获得更深层次的意识和智慧。灵性觉醒也可以帮助人们理解自身和宇宙之间的联系和本质，以及实现更高级别的人类存在和意识水平。</p><ol><li>大我意识</li></ol><p>大我意识是指个体意识到自己是大我或全能的灵魂或神，以及宇宙的本质和存在的更深层次的认知。在神秘学中，大我被视为一种超越个体自我的存在和意识，可以通过冥想、祷告、仪式和其他实践方式来体验。通过大我意识，个体可以超越物质世界的束缚，接近宇宙的本质和存在，获得更高级别的意识和智慧。</p><p>总之，意识和觉知是神秘学中最核心的主题之一。它们涉及到思维和感知的本质，以及个体和大我之间的关系。通过灵性实践和探索，个体可以超越常规意识状态，直接接触到更深刻的意识水平，以获得更高级别的洞察力和智慧。灵性觉醒和大我意识是帮助人们实现更高级别的存在和意识水平的重要实践和目标。通过这些实践，个体可以超越日常现实，探索更深层次的真相和本质，并获得更高级别的人类存在和意识水平。</p><p>在现代神秘学中，意识和觉知也与心理和认知科学等领域联系紧密。研究表明，冥想、瑜伽和其他精神实践可以改变大脑结构和功能，提高个体的注意力、情绪调节和认知能力。这表明，意识和觉知不仅是一种神秘的哲学思想，也是一个可以被科学验证和解释的现象。</p><p>总之，意识和觉知是神秘学中最核心的主题之一。它们涉及到个体思维和感知的本质，以及个体和大我之间的关系。通过灵性实践和探索，个体可以超越常规意识状态，直接接触到更深刻的意识水平，以获得更高级别的洞察力和智慧。</p><h3 id="灵性成长和自我认识"><a href="#灵性成长和自我认识" class="headerlink" title="灵性成长和自我认识"></a>灵性成长和自我认识</h3><p>灵性成长和自我认识是一个人内在修行的过程，它源于我们对自己和周围世界的深层理解。这个过程可能不同于每个人，但是它始终涉及到一些共同的主题和实践。</p><p>首先，灵性成长需要我们重新审视自己的价值观和信仰体系。这可能涉及到探索不同的哲学和宗教传统，或者更深入地了解自己的人生目标和意义。在这个过程中，我们需要学会反思和质疑自己的想法，并尝试从不同的角度来看待事物。</p><p>其次，灵性成长也需要我们与内在的自我进行沟通和交流。这意味着我们需要学会静下心来，聆听内在的声音和直觉。通过冥想、瑜伽、呼吸等实践，我们可以逐渐感受到自己内在的平静和坚定。</p><p>此外，灵性成长还需要我们关注自己的情感和心理状态。我们需要学会接纳自己的情感，而不是压抑或避免它们。通过这个过程，我们可以更好地了解自己的情感需求和弱点，并学会如何处理它们。</p><p>最后，灵性成长也需要我们与他人建立更为深入和有意义的联系。我们需要学会从爱和同情的角度看待他人，而不是从权力和利益的角度。通过与他人分享我们的经验和感悟，我们可以帮助彼此成长和进步。</p><p>总之，灵性成长和自我认识是一个持续的过程，需要我们付出时间和努力，才能达到更高的境界。它让我们更加了解自己和周围世界，更加平静和坚定地面对生活的挑战。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/Ancient%20buddha%20statue%20under%20full%20moon%20-%20Old%20temple%20at%20Prasat%20Nakhon%20Luang,%20Ayutthaya,%20Thailand.%20Photo%20-%20Stock%20Image.jpeg" alt="Ancient buddha statue under full moon - Old temple at Prasat Nakhon Luang, Ayutthaya, Thailand. Photo - Stock Image"></p><h3 id="人类意识和宇宙意识"><a href="#人类意识和宇宙意识" class="headerlink" title="人类意识和宇宙意识"></a>人类意识和宇宙意识</h3><p>人类意识和宇宙意识是哲学和宗教领域中的一些重要概念，涉及到我们对自己和周围世界的认知和理解。</p><p>首先，人类意识指的是我们作为个体所拥有的意识和思维能力。这种意识让我们能够感知和理解周围的事物，并从中提取信息和建立模型。通过这种过程，我们可以形成自我意识和自我身份，并与他人进行交流和合作。</p><p>然而，除了个体意识之外，还有一种更为广义的意识存在，即宇宙意识。宇宙意识是指整个宇宙、整个自然界所拥有的意识和智慧。这种意识超越了个体，包含了所有生命和非生命的存在，是一种更为深刻和综合的意识体系。</p><p>在一些哲学和宗教传统中，人类意识被视为宇宙意识的一个表现和组成部分。例如，印度教和佛教中的“涅槃”概念，就是指个体意识融入宇宙意识的过程。同样，在基督教中，灵魂被认为是人类的永恒意识，而上帝则是宇宙意识的化身。</p><p>此外，一些科学理论也探讨了宇宙意识的存在。例如，量子物理学中的“观察者效应”表明，观察者会改变实验结果，暗示宇宙可能具有某种形式的意识或智慧。另外，一些科学家也提出了“全息宇宙”理论，认为整个宇宙像一张大网，每个部分都包含了整个宇宙的信息。</p><p>总之，人类意识和宇宙意识是一个复杂而深奥的话题，涉及到哲学、宗教和科学等多个领域。无论是从哪个角度看待它，都需要我们用开放和好奇的心态去接纳和探索。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><p>以下是几本关于灵性、宗教和神秘学的推荐书籍：</p><ol><li>《禅的疗愈力量》（The Healing Power of Mindfulness）作者：Saki Santorelli 该书介绍了禅修和冥想如何帮助我们在身体、情感和心理方面实现平衡和健康，以及如何在日常生活中应用这些技巧。</li><li>《道德经》（Tao Te Ching）作者：老子 这是一本古老的哲学论著，探讨了人类和宇宙的本质、生命的意义和人生的智慧，对中国文化和哲学产生了深远影响。</li><li>《科学与偏见》（The Varieties of Scientific Experience）作者：卡尔·萨根 这本书记录了科学家卡尔·萨根在哈佛大学的一系列演讲，探讨了科学与宗教之间的关系、宇宙的本质和人类的生命意义等问题。</li><li>《世界宗教史》（A History of God）作者：凯伦·阿姆斯特朗 该书介绍了世界各大宗教的历史和发展，从不同角度探讨了宗教信仰和人类文明的关系，并呼吁消除宗教上的偏见和争端。</li><li>《亚伯拉罕三教》（Abraham）作者：布鲁斯·费勒曼 该书介绍了犹太教、基督教和伊斯兰教这三个亚伯拉罕宗教的历史和相互关系，以及它们如何塑造了人类文明和价值观。</li><li>《幻觉与神秘体验》（The Doors of Perception）作者：阿道司·赫胥黎 该书介绍了作家阿道司·赫胥黎通过服用麦角酸二乙酰胺（LSD）等致幻剂所产生的视觉和精神体验，并探讨了这些经验对灵性和哲学的影响。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Okkultismus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七叶一枝花</title>
      <link href="/undefinedchonglou/"/>
      <url>/undefinedchonglou/</url>
      
        <content type="html"><![CDATA[<center>七叶一枝花</center><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>七叶一枝花（学名：Paris polyphylla）为黑药花科重楼属的植物。种加词 polyphylla 意为“多片叶子的”。分布在不丹、越南、锡金、尼泊尔、台湾以及中国大陆的贵州、云南、西藏、四川等地，生长于高海拔1,800米至3,200米的地区，一般生于林下，目前尚未由人工引种栽培。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/chongllou%20(1).jpg" alt="img"></p><h3 id="产地"><a href="#产地" class="headerlink" title="产地"></a>产地</h3><p>《本草经集注》陶弘景<br>生山阳川谷及宛朐。</p><p>《中药大辞典》<br>为百合科植物具柄王孙的根茎。秋后挖取，去除茎、叶、须根，晒干。<br>生于林下阴湿处。分布四川、广西等地。产于四川。</p><h3 id="入药"><a href="#入药" class="headerlink" title="入药"></a>入药</h3><p>《神农本草经》<br>味苦，微寒。主惊痫，摇头弄舌，热气在腹中，癫疾，痈疮，阴蚀，下三虫，去蛇毒。</p><p>《本草经集注》陶弘景<br>味苦，微寒，有毒。主治惊痫，摇头弄舌，热气在腹中，癫疾，痈疮，阴蚀，下三虫，去蛇毒。</p><p>《雷公炮制药性解》李中梓<br>味苦，微寒，有毒，入心经。主惊痫癫疾，瘰疬阴蚀，痈肿毒疮，小儿胎风，手足抽掣。下三虫，去蛇毒。<br>蚤休味苦，故入心经，以治惊痫等疾，而能解毒。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 植物 </tag>
            
            <tag> 艹 </tag>
            
            <tag> 中草药 </tag>
            
            <tag> 七叶一枝花 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王不留行</title>
      <link href="/undefinedwangbuliuxing/"/>
      <url>/undefinedwangbuliuxing/</url>
      
        <content type="html"><![CDATA[<p>wei</p><center>王不留行</center><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>王不留行，中药名。为石竹科植物麦蓝菜Vaccaria segetalis( Neck.)Garcke的干燥成熟种子。夏季果实成熟、果皮尚未开裂时采割植株，晒干，打下种子，除去杂质，再晒干。除华南外，全国各地区都有分布。具有活血通经，下乳消肿，利尿通淋的功效。用于经闭，痛经，乳汁不下，乳痈肿痛，淋证涩痛。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/wblx3.jpg" alt="img"></p><h3 id="产地"><a href="#产地" class="headerlink" title="产地"></a>产地</h3><p>《本草经集注》陶弘景<br>生太山山谷。二月、八月采。今处处有。人言是蓼子，亦不尔。叶似酸浆，子似松子。而多入痈瘘方用之。<br>《中药大辞典》<br>为石竹科植物麦蓝菜的种子。四、五月麦熟时采收（东北地区在秋季）。割取全草，晒干，使果实自然开裂，然后打下种子，除去杂质，晒干。<br>生于田边或耕地附近的丘陵地，尤以麦田中最为普遍。除华南外，全国各地区都有分布。</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/wblx2.jpg" alt="img"></p><h3 id="入药"><a href="#入药" class="headerlink" title="入药"></a>入药</h3><p>《神农本草经》<br>味苦，平。主金创止血，逐痛，出刺，除风痹，内寒。久服轻身，耐老，增寿。<br>《本草经集注》陶弘景<br>味苦、甘，平，无毒。主治金疮，止血，逐痛，出刺，除风痹内寒。止心烦，鼻衄，痈疽，恶疮，瘘乳，妇人难产。久服轻身，耐老增寿。<br>《雷公炮制药性解》李中梓<br>味苦甘，性平，无毒，入心、肝二经。主金疮止血，痈疽毒疮，心烦鼻衄，难产，出竹木刺入肉，治风毒，通血脉。酒蒸，焙用。<br>王不留行专疗血证，而心主血、肝藏血者也。故均入之。痈疽等证，血不和也。《经》曰：营气不从，逆于肉理，乃生痈肿，此主和血，固宜治之。又治风毒者，所谓治风先治血，血行风自灭也。<br>《长沙药解》黄元御<br>味苦，入足厥阴肝经。疗金疮而止血，通经脉而行瘀。<br><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/web/wblx.jpg" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 植物 </tag>
            
            <tag> 艹 </tag>
            
            <tag> 中草药 </tag>
            
            <tag> 神农本草经 </tag>
            
            <tag> 王不留行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Book of Lambspring</title>
      <link href="/undefinedlamb/"/>
      <url>/undefinedlamb/</url>
      
        <content type="html"><![CDATA[<h1 id="Book-of-Lambspring"><a href="#Book-of-Lambspring" class="headerlink" title="Book of Lambspring"></a>Book of Lambspring</h1><center>The Book of Lambspring, </center><center>A Noble Ancient Philosopher, </center><center>Concerning the Philosophical Stone;</center><center> Rendered into Latin Verse by Nicholas Barnaud Delphinas, </center><center>Doctor of Medicine, a zealous Student of this Art.</center><h2 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h2><center>I am called Lambspring, born of a Noble Family, and this Crest I bear </center><center>with Glory and Justice.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs1.gif" alt="img"></p><p>Philosophy I have read, and thoroughly understood,<br>The utmost depth of my teachers’ knowledge have I sounded.<br>This God graciously granted to me,<br>Giving me a heart to understand wisdom.<br>Thus I became the Author of this Book,<br>And I have clearly set forth the whole matter,<br>That Rich and Poor might understand.<br>There is nothing like it upon earth;<br>Nor (God be praised) have I therein forgotten my humble self.<br>I am acquainted with the only true foundation:<br>Therefore preserve this Book with care,<br>And take heed that you study it again and again.<br>Thus shall you receive and learn the truth,<br>And use this great gift of God for good ends.<br>O God the Father, which art of all the beginning and end,<br>We beseech thee for the sake of our Lord Jesus Christ<br>To enlighten our minds and thoughts,<br>That we may praise Thee without ceasing,<br>And accomplish this Book according to Thy will!<br>Direct Thou everything to a good end,<br>And preserve us through Thy great mercy. -<br>With the help of God I will shew you this Art,<br>And will not hide or veil the truth from you.<br>After that you understand me aright,<br>You will soon be free from the bonds of error.<br>For there is only one substance,<br>In which all the rest is hidden;<br>Therefore, keep a good heart.<br>Coction, time, and patience are what you need;<br>If you would enjoy the precious reward,<br>You must cheerfully give both time and labour.<br>For you must subject to gentle coction the seeds and the metals,<br>Day by day, during several weeks;<br>Thus in this one vile thing<br>You will discover and bring to perfection the whole work of Philosophy,<br>Which to most men appears impossible,<br>Though it is a convenient and easy task.<br>If we were to shew it to the outer world<br>We should be derided by men, women, and children.<br>Therefore be modest and secret,<br>And you will be left in peace and security.<br>Remember your duty towards your neighbour and your God,<br>Who gives this Art, and would have it concealed.<br>Now we will conclude the Preface,<br>That we may begin to describe the very Art,<br>And truly and plainly set it forth in figures,<br>Rendering thanks to the Creator of every creature.<br>Hereunto follows the First Figure,</p><h2 id="Figure-I"><a href="#Figure-I" class="headerlink" title="Figure I"></a>Figure I</h2><p>BE WARNED AND UNDERSTAND TRULY THAT TWO FISHES ARE SWIMMING IN OUR SEA.</p><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs3.gif" alt="img"></p><center>The Sea is the Body, the two Fishes are Soul and Spirit.</center><p>The Sages will tell you<br>That two fishes are in our sea<br>Without any flesh or bones.<br>Let them be cooked in their own water;<br>Then they also will become a vast sea,<br>The vastness of which no man can describe.<br>Moreover, the Sages say<br>That the two fishes are only one, not two;<br>They are two, and nevertheless they are one,<br>Body, Spirit, and Soul.<br>Now, I tell you most truly,<br>Cook these three together,<br>That there may be a very large sea.<br>Cook the sulphur well with the sulphur,<br>And hold your tongue about it:<br>Conceal your knowledge to your own advantage,<br>And you shall be free from poverty.<br>Only let your discovery remain a close secret.</p><h2 id="Figure-II"><a href="#Figure-II" class="headerlink" title="Figure II"></a>Figure II</h2><center>HERE YOU STRAIGHTWAY BEHOLD A BLACK BEAST IN THE FOREST.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs4.gif" alt="img"></p><center>Putrefaction.</center><p>The Sage says<br>That a wild beast is in the forest,<br>Whose skin is of the blackest dye.<br>If any man cut off his head,<br>His blackness will disappear,<br>And give place to a snowy white.<br>Understand well the meaning of this head:<br>The blackness is called the head of the Raven;<br>As soon as it disappears,<br>A white colour is straightway manifested;<br>It is given this name, despoiled of its head.<br>When the Beast’s black hue has vanished in a black smoke,<br>The Sages rejoice<br>From the bottom of their hearts;<br>But they keep it a close secret,<br>That no foolish man may know it.<br>Yet unto their Sons, in kindness of heart,<br>They partly reveal it in their writings;<br>And therefore let those who receive the gift<br>Enjoy it also in silence,<br>Since God would have it concealed.</p><h2 id="Figure-III"><a href="#Figure-III" class="headerlink" title="Figure III"></a>Figure III</h2><center>HEAR WITHOUT TERROR THAT IN THE FOREST ARE HIDDEN A DEER AND AN UNICORN.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs5.gif" alt="img"></p><center>In the Body there is Soul and Spirit.</center><p>The Sages say truly<br>That two animals are in this forest:<br>One glorious, beautiful, and swift,<br>A great and strong deer;<br>The other an unicorn.<br>They are concealed in the forest,<br>But happy shall that man be called<br>Who shall snare and capture them.<br>The Masters shew you here clearly<br>That in all places<br>These two animals wander about in forests<br>(But know that the forest is but one).<br>If we apply the parable to our Art,<br>We shall call the forest the Body.<br>That will be rightly and truly said.<br>The unicorn will be the Spirit at all times.<br>The deer desires no other name<br>But that of the Soul; which name no man shall take away from it.<br>He that knows how to tame and master them by Art,<br>To couple them together,<br>And to lead them in and out of the forest,<br>May justly be called a Master.<br>For we rightly judge<br>That he has attained the golden flesh,<br>And may triumph everywhere;<br>Nay, he may bear rule over great Augustus.</p><h2 id="Figure-IV"><a href="#Figure-IV" class="headerlink" title="Figure IV"></a>Figure IV</h2><center>HERE YOU BEHOLD A GREAT MARVEL - TWO LIONS ARE JOINED INTO ONE.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs6.gif" alt="img"></p><center>The Spirit and Soul must be united in their Body.</center><p>The Sages do faithfully teach us<br>That two strong lions, to wit, male and female,<br>Lurk in a dark and rugged valley.<br>These the Master must catch,<br>Though they are swift and fierce,<br>And of terrible and savage aspect.<br>He who, by wisdom and cunning,<br>Can snare and bind them,<br>And lead them into the same forest,<br>Of him it may be said with justice and truth<br>That he has merited the meed of praise before all others,<br>And that his wisdom transcends that of the worldly wise.</p><h2 id="Figure-V"><a href="#Figure-V" class="headerlink" title="Figure V"></a>Figure V</h2><center>A WOLF AND A DOG ARE IN ONE HOUSE, AND ARE AFTERWARDS CHANGED INTO ONE.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs7.gif" alt="img"></p><center>The Body is mortified and rendered white, then joined to Soul and Spirit by being saturated with them.</center><p>Alexander writes from Persia<br>That a wolf and a dog are in this field,<br>Which, as the Sages say,<br>Are descended from the same stock,<br>But the wolf comes from the east,<br>And the dog from the west.<br>They are full of jealousy,<br>Fury, rage, and madness;<br>One kills the other,<br>And from them comes a great poison.<br>But when they are restored to life,<br>They are clearly shewn to be<br>The Great and Precious Medicine,<br>The most glorious Remedy upon earth,<br>Which refreshes and restores the Sages,<br>Who render thanks to God, and do praise Him.</p><h2 id="Figure-VI"><a href="#Figure-VI" class="headerlink" title="Figure VI"></a>Figure VI</h2><center>THIS SURELY IS A GREAT MIRACLE AND WITHOUT ANY DECEPTION -    THAT IN A VENOMOUS DRAGON THERE SHOULD BE THE GREAT MEDICINE.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs8.gif" alt="img"></p><center>The Mercury is precipitated or sublimed, dissolved in its own proper water,    and then once more coagulated.</center><p>A savage Dragon lives in the forest,<br>Most venomous he is, yet lacking nothing:<br>When he sees the rays of the Sun and its bright fire,<br>He scatters abroad his poison,<br>And flies upward so fiercely<br>That no living creature can stand before him,<br>Nor is even the Basilisk equal to him.<br>He who hath skill to slay him, wisely<br>Hath escaped from all dangers.<br>Yet all venom, and colours, are multiplied<br>In the hour of his death.<br>His venom becomes the great Medicine.<br>He quickly consumes his venom,<br>For he devours his poisonous tail.<br>All this is performed on his own body,<br>From which flows forth glorious Balm,<br>With all its miraculous virtues.<br>Hereat all the Sages do loudly rejoice.</p><h2 id="Figure-VII"><a href="#Figure-VII" class="headerlink" title="Figure VII"></a>Figure VII</h2><center>WE HEAR TWO BIRDS IN THE FOREST, YET WE MUST UNDERSTAND THEM TO BE ONLY ONE.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs9.gif" alt="img"></p><center>The Mercury having been often sublimed, is at length fixed, and becomes capable of resisting fire: the sublimation must be repeated until at length the fixation is attained.</center><p>A nest is found in the forest,<br>In which Hermes has his brood;<br>One fledgling always strives to fly upward,<br>The other rejoices to sit quietly in the nest;<br>Yet neither can get away from the other.<br>The one that is below holds the one that is above,<br>And will not let it get away from the nest,<br>As a husband in a house with his wife,<br>Bound together in closest bonds of wedlock.<br>So also do we rejoice at all times,<br>That we hold the female eagle fast in this way,<br>And we render thanks to God the Father.</p><h2 id="Figure-VIII"><a href="#Figure-VIII" class="headerlink" title="Figure VIII"></a>Figure VIII</h2><center>HERE ARE TWO BIRDS, GREAT AND STRONG - THE BODY AND SPIRIT; ONE DEVOURS THE OTHER.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs10.gif" alt="img"></p><center>Let the Body be placed in horse-dung, or a warm bath, the Spirit having been extracted from it. The Body has become white by the process, the Spirit red by our Art. All that exists tends towards perfection, and thus is the Philosopher's Stone prepared.</center><p>In India there is a most pleasant wood,<br>In which two birds are bound together.<br>One is of a snowy white; the other is red.<br>They bite each other, and one is slain<br>And devoured by the other.<br>Then both are changed into white doves,<br>And of the Dove is born a Phoenix,<br>Which has left behind blackness and foul death,<br>And has regained a more glorious life.<br>This power was given it by God Himself,<br>That it might live eternally, and never die.<br>It gives us wealth, it preserves our life,<br>And with it we may work great miracles,<br>As also the true Philosophers do plainly inform us.</p><h2 id="Figure-IX"><a href="#Figure-IX" class="headerlink" title="Figure IX"></a>Figure IX</h2><center>THE LORD OF THE FORESTS HAS RECOVERED HIS KINGDOM, AND MOUNTED FROM THE LOWEST TO THE HIGHEST DEGREE. IF FORTUNE SMILE, YOU MAY FROM A RHETOR BECOME A CONSUL; IF FORTUNE FROWN, THE CONSUL MAY BECOME A RHETOR.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs11.gif" alt="img"></p><center>Thus you may know that the Tincture has truly attained the first degree.</center><p>Now hear of a wonderful deed,<br>For I will teach you great things,<br>How the King rises high above all his race;<br>And hear also what the noble lord of the forest says:<br>I have overcome and vanquished my foes,<br>I have trodden the venomous Dragon under foot,<br>I am a great and glorious King in the earth.<br>There is none greater than I,<br>Child either of the Artist or of Nature,<br>Among all living creatures.<br>I do all that man can desire,<br>I give power and lasting health,<br>Also gold, silver, gems, and precious stones,<br>And the panacea for great and small diseases.<br>Yet at first I was of ignoble birth,<br>Till I was set in a high place.<br>To reach this lofty summit<br>Was given me by God and Nature.<br>Thence from the meanest I became the highest,<br>And mounted to the most glorious throne,<br>And to the state of royal sovereignty:<br>Therefore Hermes has called me the Lord of the Forests.</p><h2 id="Figure-X"><a href="#Figure-X" class="headerlink" title="Figure X"></a>Figure X</h2><center>A SALAMANDER LIVES IN THE FIRE, WHICH IMPARTS TO IT A MOST GLORIOUS HUE.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs12.gif" alt="img"></p><center>This is the reiteration, gradation, and ameliorationof the Tincture, or Philosopher's Stone; and the whole is called its Augmentation.</center><p>In all fables we are told<br>That the Salamander is born in the fire;<br>In the fire it has that food and life<br>Which Nature herself has assigned to it.<br>It dwells in a great mountain<br>Which is encompassed by many flames,<br>And one of these is ever smaller than another -<br>Herein the Salamander bathes.<br>The third is greater, the fourth brighter than the rest -<br>In all these the Salamander washes, and is purified.<br>Then he hies him to his cave,<br>But on the way is caught and pierced<br>So that it dies, and yields up its life with its blood.<br>But this, too, happens for its good:<br>For from its blood it wins immortal life,<br>And then death has no more power over it.<br>Its blood is the most precious Medicine upon earth,<br>The same has not its like in the world.<br>For this blood drives away all disease<br>In the bodies of metals,<br>Of men, and of beasts.<br>From it the Sages derive their science,<br>And through it they attain the Heavenly Gift,<br>Which is called the Philosopher’s Stone,<br>Possessing the power of the whole world.<br>This gift the Sages impart to us with loving hearts,<br>That we may remember them for ever.</p><h2 id="Figure-XI"><a href="#Figure-XI" class="headerlink" title="Figure XI"></a>Figure XI</h2><center>THE FATHER AND THE SON HAVE LINKED THEIR HANDS WITH THOSE OF THE GUIDE: KNOW THAT THE THREE ARE BODY, SOUL, AND SPIRIT.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs13.gif" alt="img"></p><p>Here is an old father of Israel,<br>Who has an only Son,<br>A Son whom he loves with all his heart.<br>With sorrow he prescribes sorrow to him.<br>He commits him to a guide,<br>Who is to conduct him whithersoever he will.<br>The Guide addresses the Son in these words:<br>Come hither! I will conduct thee everywhere,<br>To the summit of the loftiest mountain,<br>That thou mayest understand all wisdom,<br>That thou mayest behold the greatness of the earth, and of the sea,<br>And then derive true pleasure.<br>I will bear thee through the air<br>To the gates of highest heaven.<br>The Son hearkened to the words of the Guide,<br>And ascended upward with him;<br>There saw he the heavenly throne,<br>That was beyond measure glorious.<br>When he had beheld these things,<br>He remembered his Father with sighing,<br>Pitied the great sorrow of his Father,<br>And said: I will return to his breast.</p><h2 id="Figure-XII"><a href="#Figure-XII" class="headerlink" title="Figure XII"></a>Figure XII</h2><center>ANOTHER MOUNTAIN OF INDIA LIES IN THE VESSEL, WHICH THE SPIRIT AND THE SOUL - THAT IS, THE SON AND THE GUIDE - HAVE CLIMBED.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs14.gif" alt="img"></p><p>Says the Son to the Guide:<br>I will go down to my Father,<br>For he cannot live without me.<br>He sighs and calls aloud for me.<br>And the Guide makes answer to the Son:<br>I will not let thee go alone;<br>From thy Father’s bosom I brought thee forth,<br>I will also take thee back again,<br>That he may rejoice again and live.<br>This strength will we give unto him.<br>So both arose without delay,<br>And returned to the Father’s house.<br>When the Father saw his Son coming,<br>He cried aloud, and said: -</p><h2 id="Figure-XIII"><a href="#Figure-XIII" class="headerlink" title="Figure XIII"></a>Figure XIII</h2><center>HERE THE FATHER DEVOURS THE SON; THE SOUL AND SPIRIT FLOW FORTH FROM THE BODY.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs15.gif" alt="img"></p><p>My Son, I was dead without thee,<br>And lived in great danger of my life.<br>I revive at thy return,<br>And it fills my breast with joy.<br>But when the Son entered the Father’s house,<br>The Father took him to his heart,<br>And swallowed him out of excessive joy,<br>And that with his own mouth.<br>The great exertion makes the Father sweat.</p><h2 id="Figure-XIV"><a href="#Figure-XIV" class="headerlink" title="Figure XIV"></a>Figure XIV</h2><center>HERE THE FATHER SWEATS PROFUSELY, WHILE OIL AND THE TRUE TINCTURE OF THE SAGES FLOW FORTH FROM HIM.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs16.gif" alt="img"></p><p>Here the Father sweats on account of the Son,<br>And earnestly beseeches God,<br>Who has created everything in His hands,<br>Who creates, and has created all things,<br>To bring forth his Son from his body,<br>And to restore him to his former life.<br>God hearkens to his prayers,<br>And bids the Father lie down and sleep.<br>Then God sends down rain from heaven<br>To the earth from the shining stars.<br>It was a fertilizing, silver rain,<br>Which bedewed and softened the Father’s Body.<br>Succour us, Lord, at the end,<br>That we may obtain Thy gracious Gift!</p><h2 id="Figure-XV"><a href="#Figure-XV" class="headerlink" title="Figure XV"></a>Figure XV</h2><center>HERE FATHER AND SON ARE JOINED IN ONE SO TO REMAIN FOR EVER.</center><p><img src="https://blog-1309914759.cos.ap-guangzhou.myqcloud.com/img/lambs17.gif" alt="img"></p><p>The sleeping Father is here changed<br>Entirely into limpid water,<br>And by virtue of this water alone<br>The good work is accomplished.<br>There is now a glorified and beautiful Father,<br>And he brings forth a new Son.<br>The Son ever remains in the Father,<br>And the Father in the Son.<br>Thus in divers things<br>They produce untold, precious fruit.<br>They perish never more,<br>And laugh at death.<br>By the grace of God they abide for ever,<br>The Father and the Son, triumphing gloriously<br>In the splendour of their new Kingdom.<br>Upon one throne they sit,<br>And the face of the Ancient Master<br>Is straightway seen between them:<br>He is arrayed in a crimson robe.</p><hr><center>TO THE INVISIBLE KING</center><center>OF THE WORLD,</center><center>TO THE ONLY TRUE AND IMMORTAL GOD</center><center>BE PRAISE AND GLORY</center><center>NOW AND EVERMORE.</center><center>AMEN.</center>]]></content>
      
      
      <categories>
          
          <category> Okkultismus </category>
          
          <category> Alchemy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Okkultismus </tag>
            
            <tag> Alchemy </tag>
            
            <tag> Book </tag>
            
            <tag> western </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
